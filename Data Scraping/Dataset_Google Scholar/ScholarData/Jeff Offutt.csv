titles,authors,date,source,descriptions,citations
Introduction to software testing,"Paul Ammann, Jeff Offutt",2016/12/13,Publisher Cambridge University Press,"This extensively classroom-tested text takes an innovative approach to explaining software testing that defines it as the process of applying a few precise, general-purpose criteria to a structure or model of the software. The book incorporates cutting-edge developments, including techniques to test modern types of software such as OO, web applications, and embedded software. This revised second edition significantly expands coverage of the basics, thoroughly discussing test automaton frameworks, and it adds new, improved examples and numerous exercises. The theory of coverage criteria is carefully and cleanly explained to help students understand concepts before delving into practical applications, while extensive use of the JUnit test framework gives students practical experience in a test framework popular in the industry. Exercises, meanwhile, feature specifically tailored tools that allow students to check their own work. The book's website also offers an instructor's manual, PowerPoint slides, testing tools for students, and example software programs in Java.",2476
Constraint-based automatic test data generation,"RA DeMillo, A. Jefferson Offutt",1991/9,"Journal Software Engineering, IEEE Transactions on","This paper presents a new technique for automatically generating test data. The technique is based on mutation analysis and creates test data that approximates relative-adequacy. The technique is a fault-based technique that uses algebraic constraints to describe test cases designed to find particular types of faults. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraints and solves them to create test cases for unit and module testing. Godzilla has been integrated with the Mothra testing system and has been used as an effective way to generate test data that kills program mutants.",1186
MuJava: an automated class mutation system,"Yu‐Seung Ma, Jeff Offutt, Yong Rae Kwon",2005/6,"Journal Software Testing, Verification and Reliability","Several module and class testing techniques have been applied to object‐oriented (OO) programs, but researchers have only recently begun developing test criteria that evaluate the use of key OO features such as inheritance, polymorphism, and encapsulation. Mutation testing is a powerful testing technique for generating software tests and evaluating the quality of software. However, the cost of mutation testing has traditionally been so high that it cannot be applied without full automated tool support. This paper presents a method to reduce the execution cost of mutation testing for OO programs by using two key technologies, mutant schemata generation (MSG) and bytecode translation. This method adapts the existing MSG method for mutants that change the program behaviour and uses bytecode translation for mutants that change the program structure. A key advantage is in performance: only two compilations …",882
An Experimental Determination of Sufficient Mutant Operators,"Jeff Offutt, Gregg Rothermel, Roland H Untch, Christian Zapf",1996/4,Journal ACM Transactions on software engineering methodology,"Mutation testing is a technique, originally proposed by DeMillo et al.[1978] and Hamlet [1977], that requires a person testing a program to create test data that causes a finite, well-specified set of faults to result in failure. The tester does this by finding test cases that cause faulty versions of the program to fail. These test cases will then either result in correct output from the test program (demonstrating its quality) or cause the test program to fail (detecting a fault). The technique thus serves two goals: it provides a test adequacy criterion, and it leads to detection of faults in the program being tested.",882
Generating tests from UML specifications,"Jeff Offutt, Aynur Abdurazik",1999,Journal «UML»’99—The Unified Modeling Language,"Although most industry testing of complex software is conducted at the system level, most formal research has focused on the unit level. As a result, most system level testing techniques are only described informally. This paper presents a novel technique that adapts pre-defined state-based specification test data generation criteria to generate test cases from UML statecharts. UML statecharts provide a solid basis for test generation in a form that can be easily manipulated. This technique includes coverage criteria that enable highly effective tests to be developed. To demonstrate this technique, a tool has been developed that uses UML statecharts produced by Rational Software Corporation’s Rational Rose tool to generate test data. Experimental results from using this tool are presented.",676
Combination testing strategies: a survey,"Mats Grindal, Jeff Offutt, Sten F Andler",2005/9,"Source Software Testing, Verification and Reliability","Combination strategies are test case selection methods that identify test cases by combining values of the different test object input parameters based on some combinatorial strategy. This survey presents 16 different combination strategies, covering more than 40 papers that focus on one or several combination strategies. This collection represents most of the existing work performed on combination strategies. This survey describes the basic algorithms used by the combination strategies. Some properties of combination strategies, including coverage criteria and theoretical bounds on the size of test suites, are also included in this description. This survey paper also includes a subsumption hierarchy that attempts to relate the various coverage criteria associated with the identified combination strategies. Copyright © 2005 John Wiley & Sons, Ltd.",600
Quality attributes of web software applications,Jeff Offutt,2002/8/7,Journal IEEE software,"Web applications have very high requirements for numerous quality attributes. This article discusses some of the technological challenges of building today's complex Web software applications, their unique quality requirements, and how to achieve them.",549
Mutation 2000: Uniting the orthogonal,"A Jefferson Offutt, Ronald H Untch",2001/10/6,"Journal Mutation testing for the new century. Kluwer Academic Publishers, Norwell, MA, USA","Mutation testing is a powerful, but computationally expensive, technique for unit testing software. This expense has prevented mutation from becoming widely used in practical situations, but recent engineering advances have given us techniques and algorithms for significantly reducing the cost of mutation testing. These techniques include a new algorithmic execution technique called schema-based mutation, an approximation technique called weak mutation, a reduction technique called selective mutation, heuristics for detecting equivalent mutants, and algorithms for automatic test data generation. This paper reviews experimentation with these advances and outlines a design for a system that will approximate mutation, but in a way that will be accessible to everyday programmers. We envision a system to which a programmer can submit a program unit and get back a set of input/output pairs that are …",539
A fortran language system for mutation‐based software testing,"Kim N King, A Jefferson Offutt",1991/7/1,Journal Software: Practice and Experience,Mutation analysis is a powerful technique for testing software systems. The Mothra software testing project uses mutation analysis as the basis for an integrated software testing environment. Mutation analysis requires executing many slightly differing versions of the same program to evaluate the quality of the data used to test the program. The current version of Mothra includes a complete language system that translates a program to be tested into intermediate code so that it and its mutated versions can be executed by an interpreter.,539
Investigations of the software testing coupling effect,A Jefferson Offutt,1992/1/2,Journal ACM Transactions on Software Engineering and Methodology (TOSEM),"Fault-based testing strategies test software by focusing on specific, common types of faults. The coupling effect hypothesizes that test data sets that detect simple types of faults are sensitive enough to detect more complex types of faults. This paper describes empirical investigations into the coupling effect over a specific class of software faults. All of the results from this investigation support the validity of the coupling effect. The major conclusion from this investigation is the fact that by explicitly testing for simple faults, we are also implicitly testing for more complicated faults, giving us confidence that fault-based testing is an effective way to test software.",508
Testing web applications by modeling with FSMs,"Anneliese A Andrews, Jeff Offutt, Roger T Alexander",2005/7,Journal Software & Systems Modeling,"Researchers and practitioners are still trying to find effective ways to model and test Web applications. This paper proposes a system-level testing technique that combines test generation based on finite state machines with constraints. We use a hierarchical approach to model potentially large Web applications. The approach builds hierarchies of Finite State Machines (FSMs) that model subsystems of the Web applications, and then generates test requirements as subsequences of states in the FSMs. These subsequences are then combined and refined to form complete executable tests. The constraints are used to select a reduced set of inputs with the goal of reducing the state space explosion otherwise inherent in using FSMs. The paper illustrates the technique with a running example of a Web-based course student information system and introduces a prototype implementation to support the technique. ",496
Generating test data from state‐based specifications,"Jeff Offutt, Shaoying Liu, Aynur Abdurazik, Paul Ammann",2003/1,"Journal Software testing, verification and reliability","Although the majority of software testing in industry is conducted at the system level, most formal research has focused on the unit level. As a result, most system‐level testing techniques are only described informally. This paper presents formal testing criteria for system level testing that are based on formal specifications of the software. Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Formal specifications represent a significant opportunity for testing because they precisely describe what functions the software is supposed to provide in a form that can be automatically manipulated.",490
An experimental evaluation of selective mutation,"A Jefferson Offutt, Gregg Rothermel, Christian Zapf",1993/5/21,Conference Proceedings of the 15th international conference on Software Engineering,"Mutation testing is a technique for unit-testing software that, although powerful, is computationally expensive. The principal expense of mutation is that many variants of the test program, called mutants, must be repeatedly executed. Selective mutation is a way to approximate mutation testing that saves execution by reducing the number of mutants that must be executed. The authors report experimental results that compare selective mutation testing to standard, or nonselective, mutation testing. The results support the hypothesis that selective mutation is almost as strong as nonselective mutation. In experimental trials, selective mutations provide almost the same coverage as nonselective mutation, with significant reductions in cost.< >",418
Automatically detecting equivalent mutants and infeasible paths,"A Jefferson Offutt, Jie Pan",1997/9/1,"Journal Software Testing, Verification and Reliability","Mutation testing is a technique for testing software units that has great potential for improving the quality of testing, and thereby increasing the ability to assure the high reliability of critical software. It will be shown that recent advances in mutation research have brought a practical mutation testing system closer to reality. One recent advance is a partial solution to the problem of automatically detecting equivalent mutant programs. Equivalent mutants are currently detected by hand, which makes it very expensive and time‐consuming. The problem of detecting equivalent mutants is a specific instance of a more general problem, commonly called the feasible path problem, which says that for certain structural testing criteria some of the test requirements are infeasible in the sense that the semantics of the program imply that no test case satisfies the test requirements. Equivalent mutants, unreachable statements in path …",398
An extended overview of the Mothra software testing environment,"Richard A DeMillo, Dany S Guindi, WM McCracken, AJ Offutt, KN King",1988/7/19,"Conference Software Testing, Verification, and Analysis, 1988., Proceedings of the Second Workshop on","The authors give a brief introduction to mutation analysis. They they discuss Mothra, emphasizing how it interacts with the tester. The authors present some major problems with using mutation analysis and discuss possible solutions. They conclude with a solution to one of these problems-a method of automatically generating mutation-adequate data.<>",394
Using UML collaboration diagrams for static checking and test generation,"Aynur Abdurazik, Jeff Offutt",2000,Journal «UML» 2000—The Unified Modeling Language,"Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Tests are commonly generated from program source code, graphical models of software (such as control flow graphs), and specifications/requirements. UML collaboration diagrams represent a significant opportunity for testing because they precisely describe how the functions the software provides are connected in a form that can be easily manipulated by automated means. This paper presents novel test criteria that are based on UML collaboration diagrams. The most novel aspect of this is that tests can be generated automatically from the software design, rather than the code or the specifications. Criteria are defined for both static and dynamic testing of specification-level and instance-level collaboration diagrams. These criteria allow a formal integration tests to be based on high level design notations …",371
Inter-class mutation operators for Java,"Yu-Seung Ma, Yong-Rae Kwon, Jeff Offutt",2002/11/12,"Conference 13th International Symposium on Software Reliability Engineering, 2002. Proceedings.","The effectiveness of mutation testing depends heavily on the types of faults that the mutation operators are designed to represent. Therefore, the quality of the mutation operators is key to mutation testing. Mutation testing has traditionally been applied to procedural-based languages, and mutation operators have been developed to support most of their language features. Object-oriented programming languages contain new language features, most notably inheritance, polymorphism, and dynamic binding. Not surprisingly; these language features allow new kinds of faults, some of which are not modeled by traditional mutation operators. Although mutation operators for OO languages have previously been suggested, our work in OO faults indicate that the previous operators are insufficient to test these OO language features, particularly at the class testing level. This paper introduces a new set of class mutation …",328
Mutation testing using mutant schemata,"Roland Untch, A Jefferson Offutt, Mary Jean Harrold",1993/6,Journal Proc. International Symposium on Software Testing and Analysis (ISSTA),,295
Generating test cases for web services using data perturbation,"Jeff Offutt, Wuzhi Xu",2004/9/1,Journal ACM SIGSOFT Software Engineering Notes,"Web services have the potential to dramatically reduce the complexities and costs of software integration projects. The most obvious and perhaps most significant difference between Web services and traditional applications is that Web services use a common communication infrastructure, XML and SOAP, to communicate through the Internet. The method of communication introduces complexities to the problems of verifying and validating Web services that do not exist in traditional software. This paper presents a new approach to testing Web services based on data perturbation. Existing XML messages are modified based on rules defined on the message grammars, and then used as tests. Data perturbation uses two methods to test Web services: data value perturbation and interaction perturbation. Data value perturbation modifies values according to the data type. Interaction perturbation classifies the …",279
An empirical evaluation of weak mutation,"A. Jefferson  Offutt, Stephen D.  Lee",1994/5,"Journal Software Engineering, IEEE Transactions on","Mutation testing is a fault-based technique for unit-level software testing. Weak mutation was proposed as a way to reduce the expense of mutation testing. Unfortunately, weak mutation is also expected to provide a weaker test of the software than mutation testing does. This paper presents results from an implementation of weak mutation, which we used to evaluate the effectiveness versus the efficiency of weak mutation. Additionally, we examined several options in an attempt to find the most appropriate way to implement weak mutation. Our results indicate that weak mutation can be applied in a manner that is almost as effective as mutation testing, and with significant computational savings.< >",277
MuJava: a mutation system for Java,"Yu-Seung Ma, Jeff Offutt, Yong-Rae Kwon",2006/5/28,Book Proceedings of the 28th international conference on Software engineering,"Mutation testing is a valuable experimental research technique that has been used in many studies. It has been experimentally compared with other test criteria, and also used to support experimental comparisons of other test criteria, by using mutants as a method to create faults. In effect, mutation is often used as a ``gold standard'' for experimental evaluations of test methods. Although mutation testing is powerful, it is a complicated and computationally expensive testing method. Therefore, automated tool support is indispensable for conducting mutation testing. This demo presents a publicly available mutation system for Java that supports both method-level mutants and class-level mutants. MuJava can be freely downloaded and installed with relative ease under both Unix and Windows. MuJava is offered as a free service to the community and we hope that it will promote the use of mutation analysis for …",274
Algorithmic analysis of the impact of changes to object-oriented software,"Li Li, A Jefferson Offutt",1996/11/4,"Conference Software Maintenance 1996, Proceedings., International Conference on","As software ages and evolves, tasks of maintaining it become more complex and more expensive. Without change impact analysis, engineers could make critical changes in the dark that could cause major problems or big ripple effects in the system. In this paper, we analyze the possible changes that could happen in object-oriented software, how these changes affect other classes in the system, and describes a set of algorithms that can find out all the possibly affected classes if these changes happened. This technique allows software developers to perform “what if” analysis on the impact of proposed process changes in the object-oriented system, choose the proposed change that causes the minimum impact on the system. Once the change is committed, it allows software testers to know what the areas are in the software system that are possibly affected by the change and retest only those classes instead of whole system and still feel confident about the software.",272
The dynamic domain reduction procedure for test data generation,"A Jefferson Offutt, Zhenyi Jin, Jie Pan",1999/2,Journal Software: Practice and Experience,"Test data generation is one of the most technically challenging steps of testing software, but most commercial systems currently incorporate very little automation for this step. This paper presents results from a project that is trying to find ways to incorporate test data generation into practical test processes. The results include a new procedure for automatically generating test data that incorporates ideas from symbolic evaluation, constraint‐based testing, and dynamic test data generation. It takes an initial set of values for each input, and dynamically ‘pushes’ the values through the control‐flow graph of the program, modifying the sets of values as branches in the program are taken. The result is usually a set of values for each input parameter that has the property that any choice from the sets will cause the path to be traversed. This procedure uses new analysis techniques, offers improvements over previous research …",264
An experimental evaluation of data flow and mutation testing,"A. Jefferson  Offutt, Jie Pan, Kanupriya Tewary, Tong Zhang",1996/2/1,Journal Software Practice and Experience,"Two experimental comparisons of data flow and mutation testing are presented. These techniques are widely considered to be effective for unit‐level software testing, but can only be analytically compared to a limited extent. We compare the techniques by evaluating the effectiveness of test data developed for each. We develop ten independent sets of test data for a number of programs: five to satisfy the mutation criterion and five to satisfy the all‐uses data‐flow criterion. These test sets are developed using automated tools, in a manner consistent with the way a test engineer might be expected to generate test data in practice. We use these test sets in two separate experiments. First we measure the effectiveness of the test data that was developed for one technique in terms of the other. Second, we investigate the ability of the test sets to find faults. We place a number of faults into each of our subject programs, and …",262
Procedures for reducing the size of coverage-based test sets,"Jeff Offutt, Jie Pan, Jeffrey M Voas",1995/6,Journal Proceedings of the 12th International Conference on Testing Computer Software,"This paper addresses the problem of reducing the size of test sets for regression testing and test output inspection. Since regression testing requires the execution of some, and in the worst case, all test cases, reducing the number of tests can have a large benefit. Additionally, testers generally have to examine the output of each test case, both during initial and regression testing. Since this is done by hand, reducing the number of outputs that need to be examined can reduce the cost of testing. We observe that for mutation-based test sets, the order in which the test cases are executed impacts the size of the test sets. This paper presents several strategies for selecting a smaller number of test cases by reordering the test tests. We illustrate our technique using a proof-of-concept empirically study using mutation testing, achieving approximately a 33 reduction in size, and a corresponding reduction in the cost of regression testing, with a cost of only one extra run of the test case set. We suggest that these results should be extendable to apply to any test strategy that includes a quantifiable measure of test case effectiveness, such as data flow testing and branch testing, and try it with statement coverage with positive results.",251
A semantic model of program faults,"A Jefferson Offutt, J Huffman Hayes",1996/5/1,Journal ACM SIGSOFT Software Engineering Notes,"Program faults are artifacts that are widely studied, but there are many aspects of faults that we still do not understand. In addition to the simple fact that one important goal during testing is to cause failures and thereby detect faults, a full understanding of the characteristics of faults is crucial to several research areas in testing. These include fault-based testing, testability, mutation testing, and the comparative evaluation of testing strategies. In this workshop paper, we explore the fundamental nature of faults by looking at the differences between a syntactic and semantic characterization of faults. We offer definitions of these characteristics and explore the differentiation. Specifically, we discuss the concept of ""size"" of program faults --- the measurement of size provides interesting and useful distinctions between the syntactic and semantic characterization of faults. We use the fault size observations to make several …",239
Criteria for generating specification-based tests,"A Jefferson Offutt, Yiwei Xiong, Shaoying Liu",1999/10,"Conference Engineering of Complex Computer Systems, 1999. ICECCS'99. Fifth IEEE International Conference on","This paper presents general criteria for generating test inputs from state-based specifications. Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Formal specifications of complex systems represent a significant opportunity for testing because they precisely describe what functions the software is supposed to provide in a form that can easily be manipulated. These techniques provide coverage criteria that are based on the specifications, and are made up of several parts, including test prefixes that contain inputs necessary to put the software into the appropriate state for the test values. The test generation process includes several steps for transforming specifications to tests. Empirical results from a comparative case study application of these criteria are presented.",221
Using compiler optimization techniques to detect equivalent mutants,"A Jefferson Offutt, W Michael Craft",1994,"Journal Software Testing, Verification and Reliability","Mutation analysis is a software testing technique that requires the tester to generate test data that will find specific, well‐defined errors. Mutation testing executes many slightly differing versions, called mutants, of the same program to evaluate the quality of the data used to test the program. Although these mutants are generated and executed efficiently by automated methods, many of the mutants are functionally equivalent to the original program and are not useful for testing. Recognizing and eliminating equivalent mutants is currently done by hand, a time‐consuming and arduous task. This problem is currently a major obstacle to the practical application of mutation testing.",213
Establishing theoretical minimal sets of mutants,"Paul Ammann, Marcio Eduardo Delamaro, Jeff Offutt",2014/3/31,"Conference 2014 IEEE seventh international conference on software testing, verification and validation","Mutation analysis generates tests that distinguish variations, or mutants, of an artifact from the original. Mutation analysis is widely considered to be a powerful approach to testing, and hence is often used to evaluate other test criteria in terms of mutation score, which is the fraction of mutants that are killed by a test set. But mutation analysis is also known to provide large numbers of redundant mutants, and these mutants can inflate the mutation score. While mutation approaches broadly characterized as reduced mutation try to eliminate redundant mutants, the literature lacks a theoretical result that articulates just how many mutants are needed in any given situation. Hence, there is, at present, no way to characterize the contribution of, for example, a particular approach to reduced mutation with respect to any theoretical minimal set of mutants. This paper's contribution is to provide such a theoretical foundation for …",197
Using formal methods to derive test frames in category-partition testing,"Paul Ammann, Jeff Offutt",1994/6/27,Conference Proceedings of COMPASS'94-1994 IEEE 9th Annual Conference on Computer Assurance,"Testing is a standard method of assuring that software performs as intended. We extend the category-partition method, which is a specification-based testing method. An important aspect of category-partition testing is the construction of test specifications as an intermediate between functional specifications and actual tests. We define a minimal coverage criterion for category-partition test specifications identify a mechanical process to produce a test specification that satisfies the criterion, and discuss the problem of resolving infeasible combinations of choices for categories. Our method uses formal schema-based functional specifications and is shown to be feasible with an example study of a simple file system.< >",192
Experimental results from an automatic test case generator,"Richard A DeMillo, A Jefferson Offutt",1993/4/1,Journal ACM Transactions on Software Engineering and Methodology (TOSEM),"Constraint-based testing is a novel way of generating test data to detect specific types of common programming faults. The conditions under which faults will be detected are encoded as mathematical systems of constraints in terms of program symbols. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraint systems and solves them to create test cases for use by the Mothra testing system. Experimental results from using Godzilla show that the technique can produce test data that is very close in terms of mutation adequacy to test data that is produced manually, and at substantially reduced cost. Additionally, these experiments have suggested a new procedure for unit testing, where test cases are viewed as throw-away items rather than scarce resources.",192
Testing web services by XML perturbation,"Wuzhi Xu, Jeff Offutt, Juan Luo",2005/11/8,Conference 16th IEEE International Symposium on Software Reliability Engineering (ISSRE'05),"The eXtensible Markup Language (XML) is widely used to transmit data across the Internet. XML schemas are used to defile the syntax of XML messages. XML-based applications can receive messages from arbitrary applications, as long as they follow the protocol defined by the schema. A receiving application must either validate XML messages, process the data in the XML message without validation, or modify the XML message to ensure that it conforms to the XML schema. A problem for developers is how well the application performs the validation, data processing, and, when necessary, transformation. This paper describes and gives examples of a method to generate tests for XML-based communication by modifying and then instantiating XML schemas. The modified schemas are based on precisely defined schema primitive perturbation operators",189
Correcton to SOFL: A formal engineering methodology for industrial applicatoins,"Shaoying Liu, AJ Offutt, C Ho-Stuart",1998/5,"Journal Software Engineering, IEEE Transactions on","Shaoying Liu holds a BSc, and an MSc degree in computer science from Xi’an Jiaotong University, the People’s Republic of China, and a PhD in formal methods from the University of Manchester, United Kingdom. He is an associate professor in the Computer Science Department at Hiroshima City University. Dr. Liu worked as an assistant lecturer and a lecturer at Xi’an Jiaotong University; a research associate at the University of York; and a research assistant at the Royal Holloway and Bedford New College of the University of London, respectively, before 1994. He was a visiting research fellow, by invitation, at The Queen’s University of Belfast from December 1994 to February 1995 His research interests include formal methods, software development methodology, software evolution, software testing, software engineering environments, formal languages, and safety critical systems. Dr. Liu received an …",184
Modeling presentation layers of web applications for testing,"Jeff Offutt, Ye Wu",2010/4/1,Journal Softw. Syst. Model.,"Web software applications have become complex, sophisticated programs that are based on novel computing technologies. Their most essential characteristic is that they represent a different kind of software deployment—most of the software is never delivered to customers’ computers, but remains on servers, allowing customers to run the software across the web. Although powerful, this deployment model brings new challenges to developers and testers. Checking static HTML links is no longer sufficient; web applications must be evaluated as complex software products. This paper focuses on three aspects of web applications that are unique to this type of deployment:(1) an extremely loose form of coupling that features distributed integration,(2) the ability that users have to directly change the potential flow of execution, and (3) the dynamic creation of HTML forms. Taken together, these aspects allow the potential control flow to vary with each execution, thus the possible control flows cannot be determined statically, prohibiting several standard analysis techniques that are fundamental to many software engineering activities. This paper presents a new way to model web applications, based on software couplings that are new to web applications, dynamic flow of control, distributed integration, and partial dynamic web application development. This model is based on the notion of atomic sections, which allow analysis tools to build the analog of a control flow graph for web applications. The atomic section model has numerous applications in web applications; this paper applies the model to the problem of testing web applications.",177
"An experimental comparison of four unit test criteria: Mutation, edge-pair, all-uses and prime path coverage","Nan Li, Upsorn Praphamontripong, Jeff Offutt",2009/4/1,"Conference 2009 International Conference on Software Testing, Verification, and Validation Workshops","With recent increased expectations for quality, and the growth of agile processes and test driven development, developers are expected to do more and more effective unit testing. Yet, our knowledge of when to use the various unit level test criteria is incomplete. The paper presents results from a comparison of four unit level software testing criteria. Mutation testing, prime path coverage, edge pair coverage, and all-uses testing were compared on two bases: the number of seeded faults found and the number of tests needed to satisfy the criteria. The comparison used a collection of Java classes taken from various sources and hand-seeded faults. Tests were designed and generated mostly by hand with help from tools that compute test requirements and muJava. The findings are that mutation tests detected more faults and the other three criteria were very similar. The paper also presents a secondary measure, a …",175
A software metric system for module coupling,"A Jefferson Offutt, Mary Jean Harrold, Priyadarshan Kolte",1993/3/1,Journal Journal of Systems and Software,"Low module coupling is considered to be a desirable quality for modular programs to have. Previously, coupling has been defined subjectively and not quantified, making it difficult to use in practice. In this article, we extend previous work to reflect newer programming languages and quantify coupling by developing a general software metric system that allows us to automatically measure coupling. We have precisely defined the levels of coupling so that they can be determined algorithmically, incorporated the notion of direction into the coupling levels, and accounted for different types of nonlocal variables present in modern programming languages. With our system, we can measure the coupling between all pairs of modules in a system, measure the coupling of a particular module with all other modules in a system, and measure the coupling of an entire system. We have implemented our metric system so that it …",170
UML-based integration testing for component-based software,"Ye Wu, Mei-Hwa Chen, Jeff Offutt",2003,"Conference COTS-Based Software Systems: Second International Conference, ICCBSS 2003 Ottawa, Canada, February 10–12, 2003 Proceedings 2","Component-based software engineering is increasingly being adopted for software development. Currently, components delivered by component providers only include specifications of the interfaces. This imposes significant dificulties on adequate testing of an integrated component-based system. Without source code, many testing techniques will not be applicable. The Unified Modeling Language (UML) has been widely adopted in component-based software development processes. Many of its useful tools, such as interaction diagrams, statechart diagrams, and component diagrams, characterize the behavior of components in various aspects, and thus can be used to help test componentbased systems. In this paper, we first analyze different test elements that are critical to test component-based software, then we propose a group of UML-based test adequacy criteria that can be used to test …",162
The coupling effect: fact or fiction,A Offutt,1989/11/1,Journal ACM SIGSOFT Software Engineering Notes,"Fault-based testing strategies test software by focusing on specific, common types of errors. The coupling effect states that test data sets that detect simple types of faults are sensitive enough to detect more complex types of faults. This paper describes empirical investigations into the coupling effect over a specific domain of software faults. All the results from this investigation support the validity of the coupling effect. The major conclusion from this investigation is that by explicitly testing for simple faults, we are also implicitly testing for more complicated faults. This gives us confidence that fault-based testing is an effective means of testing software.",162
An evaluation of combination strategies for test case selection,"Mats Grindal, Birgitta Lindström, Jeff Offutt, Sten F Andler",2006/12,Journal Empirical Software Engineering,"This paper presents results from a comparative evaluation of five combination strategies. Combination strategies are test case selection methods that combine “interesting” values of the input parameters of a test subject to form test cases. This research comparatively evaluated five combination strategies; the All Combination strategy (AC), the Each Choice strategy (EC), the Base Choice strategy (BC), Orthogonal Arrays (OA) and the algorithm from the Automatic Efficient Test Generator (AETG). AC satisfies n-wise coverage, EC and BC satisfy 1-wise coverage, and OA and AETG satisfy pair-wise coverage. The All Combinations strategy was used as a “gold standard” strategy; it subsumes the others but is usually too expensive for practical use. The others were used in an experiment that used five programs seeded with 128 faults. The combination strategies were evaluated with respect to the number of test …",156
Maintainability of the Linux kernel,"Stephen R.  Schach, Bo Jin, David R.  Wright, Gillian Z.  Heller, A. Jefferson  Offutt",2002/2,"Journal Software, IEE Proceedings-","The authors have examined 365 versions of Linux. For every version, they counted the number of instances of common (global) coupling between each of the 17 kernel modules and all the other modules in that version of Linux. They found that the number of instances of common coupling grows exponentially with the version number. This result is significant at the 99.99% level, and no additional variables are needed to explain this increase. On the other hand, the number of lines of code in each kernel module grows only linearly with the version number. They conclude that, unless Linux is restructured with a bare minimum of common coupling, the dependencies induced by common coupling will, at some future date, make Linux exceedingly hard to maintain without inducing regression faults.",155
Generating test data from SOFL specifications,"A Jefferson Offutt, Shaoying Liu",1999/12/15,Journal Journal of Systems and Software,"Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Tests are commonly generated from the source code, control flow graphs, design representations, and specifications/requirements. Formal specifications represent a significant opportunity for testing because they precisely describe what  functions the software is supposed to provide in a form that can be easily manipulated. This paper presents a new method for generating tests from formal specifications. This method is comprehensive in specification coverage, applies at several levels of abstraction, and can be highly automated. The paper applies the method to SOFL specifications, describes the technique, and demonstrates the application on a case study. A preliminary evaluation using a code-level coverage criterion (mutation testing), indicates that the method can result in very effective tests.",144
Coverage criteria for logical expressions,"Paul Ammann, Jeff Offutt, Hong Huang",2003/11/17,"Conference 14th International Symposium on Software Reliability Engineering, 2003. ISSRE 2003.","A large number of coverage criteria to generate tests from logical expressions have been proposed. Although there have been large variations in the terminology, the articulation of the criteria and the original source of the expressions, many of these criteria are fundamentally the same. The most commonly known and widely used criterion is that of modified condition decision coverage (MCDC), but some articulations of MCDC have had some ambiguities. This has led to confusion on the part of testers, students, and tool developers on how best to implement these test criteria. This paper presents a complete comprehensive set of criteria that incorporate all the existing criteria, and eliminates the ambiguities by introducing precise definitions of the various possibilities.",140
Bypass testing of web applications,"Jeff Offutt, Ye Wu, Xiaochen Du, Hong Huang",2004/11/2,Conference 15th International Symposium on Software Reliability Engineering,"Web software applications are increasingly being deployed in sensitive situations. Web applications are used to transmit, accept and store data that is personal, company confidential and sensitive. Input validation testing (IVT) checks user inputs to ensure that they conform to the program's requirements, which is particularly important for software that relies on user inputs, including Web applications. A common technique in Web applications is to perform input validation on the client with scripting languages such as JavaScript. An insidious problem with client-side input validation is that end users can bypass this validation. Bypassing validation can cause failures in the software, and can also break the security on Web applications, leading to unauthorized access to data, system failures, invalid purchases and entry of bogus data. We are developing a strategy called bypass testing to create client-side tests for Web …",138
Detecting equivalent mutants and the feasible path problem,"A Jefferson Offutt, Jie Pan",1996/6/17,Conference Proceedings of 11th Annual Conference on Computer Assurance. COMPASS'96,"Mutation testing is a technique for testing software units that has great potential for improving the quality of testing, and thereby increasing our ability to assure the high reliability of critical software. The paper presents a technique that uses mathematical constraints to automatically detect equivalent mutant programs. The paper also describes how the approach is used for the feasible path problem. The paper describes how test criteria are formalized as mathematical constraint systems, how equivalent mutants are represented as infeasible constraints, and how infeasible constraints are detected. A proof of concept implementation has been developed to demonstrate this technique, and experimental results from using this tool are presented. Limitations of the system and the method are described, and proposals for improvements are made.",138
Coupling‐based criteria for integration testing,"Zhenyi Jin, A Jefferson Offutt",1998/9,"Journal Software Testing, Verification and Reliability","Integration testing is an important part of the testing process, but few integration testing techniques have been systematically studied or defined. The goal of this research is to develop practical, effective, formalizable, automatable techniques for testing of connections between components during software integration. This paper presents an integration testing technique that is based on couplings between software components. This technique can be used to support integration testing of software components, and satisfies part of the USA's Federal Aviation Authority's requirements for structural coverage analysis of software. The coupling‐based testing technique is described, and the coverage criteria for three types of couplings are defined. Techniques and algorithms for developing coverage analysers to measure the extent to which a test set satisfies the criteria are presented, and results from a comparative case …",134
A fault model for subtype inheritance and polymorphism,"Jeff Offutt, Roger Alexander, Ye Wu, Quansheng Xiao, Chuck Hutchinson",2001/11/27,Conference Proceedings 12th International Symposium on Software Reliability Engineering,"Although program faults are widely studied, there are many aspects of faults that we still do not understand, particularly about OO software. In addition to the simple fact that one important goal during testing is to cause failures and thereby detect faults, a full understanding of the characteristics of faults is crucial to several research areas. The power that inheritance and polymorphism brings to the expressiveness of programming languages also brings a number of new anomalies and fault types. This paper presents a model for the appearance and realization of OO faults and defines and discusses specific categories of inheritance and polymorphic faults. The model and categories can be used to support empirical investigations of object-oriented testing techniques, to inspire further research into object-oriented testing and analysis, and to help improve design and development of object-oriented software.",128
A practical system for mutation testing: help for the common programmer,A Jefferson Offutt,1994/10/2,"Conference Proceedings., International Test Conference","Mutation testing is a technique for unit testing software that, although powerful, is computationally expensive. Recent engineering advances have given us techniques and algorithms for significantly reducing the cost of mutation testing. These techniques include a new algorithmic execution technique called schema-based mutation, an approximation technique called weak mutation, a reduction technique called selective mutation, and algorithms for automatic test data generation. This paper outlines a design for a system that will approximate mutation, but in a way that will be accessible to everyday programmers. We envisage a system to which a programmer can submit a program unit, and get back a set of input/output pairs that are guaranteed to form an effective test of the unit by being close to mutation adequate.",128
The class-level mutants of MuJava,"Jeff Offutt, Yu-Seung Ma, Yong-Rae Kwon",2006/5/23,Book Proceedings of the 2006 international workshop on Automation of software test,"This paper presents results from empirical studies of object-oriented, class level mutation operators, using the automated analysis and testing tool MuJava. Class mutation operators modify OO programming language features such as inheritance, polymorphism, dynamic binding and encapsulation. This paper presents data from 866 classes in six open-source programs. Several new class-level mutation operators are defined in this paper and an analysis of the number of mutants generated is provided. Techniques for eliminating some equivalent mutants are described and data from an automated tool are provided. One important result is that class-level mutation operators yield far more equivalent mutants than traditional, statement-level, operators. Another is that there are far fewer class-level mutants than statement-level mutants. Together, these data suggest that mutation for inter-class testing can be practically …",127
Mutation operators for Ada,"A Jefferson Offutt, Jeff Voas, Jeff Payne",1996/10,"Publisher Technical Report ISSE-TR-96-09, Information and Software Systems Engineering, George Mason University","Mutation analysis is a method for testing software. It provides a method for assessing the adequacy of test data. This report describes the mutation operators defined for the Ada programming language. The mutation operators are categorized using syntactic criteria, in a form suitable for an implementor of a mutation-based system, or a tester wishing to understand how mutation analysis can be used to test Ada programs.",127
Generating test cases for XML-based Web component interactions using mutation analysis,"Suet Chun Lee, Jeff Offutt",2001/11/27,Conference Proceedings 12th International Symposium on Software Reliability Engineering,"Web software systems are built using heterogeneous software components. They interact by passing messages that exchange data and activity state information. Such heterogeneous message transfers can be structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. Parsers have been developed to check the syntax of component interactions, but there are as yet no techniques for checking the semantic correctness of the interactions. The paper presents a technique for using mutation analysis to test the semantic correctness of XML-based component interactions. The Web software interactions are specified using an Interaction Specification Model (ISM) that consists of document type definitions, messaging specifications, and a set of constraints. Test cases are XML messages that are passed between the Web software components. Classes of interaction-specific …",120
SE 2014: Curriculum guidelines for undergraduate degree programs in software engineering,"Mark Ardis, David Budgen, Gregory W Hislop, Jeff Offutt, Mark Sebern, Willem Visser",2015/11/1,Journal Computer,"Over the past decade, under-graduate curriculum guidelines for computer engineering, computer science, information technology, information systems, and software engineering, produced under the aegis of ACM and the IEEE Computer Society, have supported worldwide curriculum development.",112
Empirical evaluation of the statement deletion mutation operator,"Lin Deng, Jeff Offutt, Nan Li",2013/3/18,"Conference 2013 IEEE Sixth International Conference on Software Testing, Verification and Validation","Mutation analysis is widely considered to be an exceptionally effective criterion for designing tests. It is also widely considered to be expensive in terms of the number of test requirements and in the amount of execution needed to create a good test suite. This paper posits that simply deleting statements, implemented with the statement deletion (SDL) mutation operators in Mothra, is enough to get very good tests. A version of the SDL operator for Java was designed and implemented inside the muJava mutation system. The SDL operator was applied to 40 separate Java classes, tests were designed to kill the non-equivalent SDL mutants, and then run against all mutants.",106
Determining the distribution of maintenance categories: Survey versus measurement,"Stephen R Schach, BO Jin, Liguo Yu, Gillian Z Heller, Jeff Offutt",2003/12,Journal Empirical Software Engineering,"In 1978, Lientz, Swanson, and Tompkins published the results of a survey on software maintenance. They found that 17.4% of maintenance effort was categorized as corrective in nature, 18.2% as adaptive, 60.3% as perfective, and 4.1% was categorized as other. We refer to this as the “LST” result. We contrast this survey-based result with our empirical results from the analysis of data for the repeated maintenance of three software products: a commercial real-time product, the Linux kernel, and GCC. For all three products and at both levels of granularity we considered, our observed distributions of maintenance categories were statistically very highly significantly different from LST. In particular, corrective maintenance was always more than twice the LST value. For the summed data, the percentage of corrective maintenance was more than three times the LST value. We suggest various explanations for the …",103
"A mutation carol: Past, present and future",Jeff Offutt,2011/10/1,Source Information and Software Technology,"The field of mutation analysis has been growing, both in the number of published papers and the number of active researchers. This special issue provides a sampling of recent advances and ideas. But do all the new researchers know where we started?",102
The Mothra tool set (software testing),"BJ Choi, Richard A DeMillo, Edward W Krauser, RJ Martin, AP Mathur, A Jefferson Offutt, Hsin Pan, Eugene H Spafford",1989/1/3,"Conference System Sciences, 1989. Vol. II: Software Track, Proceedings of the Twenty-Second Annual Hawaii International Conference on","Mothra is a software test environment that supports mutation-based testing of software systems. Mutation analysis is a powerful software testing technique that evaluates the adequacy of test data based on its ability to differentiate between the program under test and its mutants, where mutants are constructed by inserting single, simple errors into the program under test. This evaluation process also provides guidance in the creation of new test cases to provide more adequate testing. Mothra consists of a collection of individual tools, each of which implements a separate, independent function for the testing system. The initial Mothra tool set, for the most part, duplicates functionality existing in previous mutation analysis systems. Current efforts are concentrated on extending this basic tool set to include capabilities previously unavailable to the software testing community. The authors describe Mothra tool set and …",102
Mutation operators for testing Android apps,"Lin Deng, Jeff Offutt, Paul Ammann, Nariman Mirzaei",2017/1/1,Journal Information and Software Technology,"Context: Due to the widespread use of Android devices, Android applications (apps) have more releases, purchases, and downloads than apps for any other mobile devices. The sheer volume of code in these apps creates significant concerns about the quality of the software. However, testing Android apps is different from testing traditional Java programs due to the unique program structure and new features of apps. Simple testing coverage criteria such as statement coverage are insufficient to assure high quality of Android apps. While researchers show significant interest in finding better Android testing approaches, there is still a lack of effective and usable techniques to evaluate their proposed test selection strategies, and to ensure a reasonable number of effective tests.",97
Analyzing the validity of selective mutation with dominator mutants,"Bob Kurtz, Paul Ammann, Jeff Offutt, Márcio E Delamaro, Mariet Kurtz, Nida Gökçe",2016/11/1,Book Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering,"Various forms of selective mutation testing have long been accepted as valid approximations to full mutation testing. This paper presents counterevidence to traditional selective mutation. The recent development of dominator mutants and minimal mutation analysis lets us analyze selective mutation without the noise introduced by the redundancy inherent in traditional mutation. We then exhaustively evaluate all small sets of mutation operators for the Proteum mutation system and determine dominator mutation scores and required work for each of these sets on an empirical test bed. The results show that all possible selective mutation approaches have poor dominator mutation scores on at least some of these programs. This suggests that to achieve high performance with respect to full mutation analysis, selective approaches will have to become more sophisticated, possibly by choosing mutants based on the …",92
Mutant subsumption graphs,"Bob Kurtz, Paul Ammann, Marcio E Delamaro, Jeff Offutt, Lin Deng",2014/3/31,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation Workshops","Mutation testing researchers have long known that many generated mutants are not needed. This paper develops a graph model to describe redundancy among mutations. We define ""true"" subsumption, a relation that practicing test engineers would like to have, but cannot due to issues of computability. We also define dynamic subsumption and static subsumption as approximations of ""true"" subsumption. We explore the properties of the approximate subsumption relations in the context of a small example. We suggest possible uses for subsumption graphs.",92
An experimental mutation system for Java,"Jeff Offutt, Yu-Seung Ma, Yong-Rae Kwon",2004/9/1,Journal ACM SIGSOFT Software Engineering Notes,"Mutation is a powerful but complicated and computationally expensive testing method. Mutation is also a valuable experimental research technique that has been used in many studies. Mutation has been experimentally compared with other test criteria, and also used to support experimental comparisons of other test criteria, by using mutants as a method to create faults. In effect, mutation is often used as a ""gold standard"" for experimental evaluations of test methods. This paper presents a publicly available mutation system for Java that supports both traditional statement-level mutants and newer inter-class mutants. MUJAVA can be freely downloaded and installed with relative ease under both Unix and Windows. MUJAVA is offered as a free service to the community and we hope that it will promote the use of mutation analysis for experimental research in software testing.",88
Estimation and enhancement of real-time software reliability through mutation analysis,"Robert Geist, A. Jefferson  Offutt, Frederick C Harris, J R I C K C",1992/5/1,Journal IEEE Transactions on Computers,"A simulation-based method for obtaining numerical estimates of the reliability of N-version, real-time software is proposed. An extended stochastic Petri net is used to represent the synchronization structure of N versions of the software, where dependencies among versions are modeled through correlated sampling of module execution times. The distributions of execution times are derived from automatically generated test cases that are based on mutation testing. Since these test cases are designed to reveal software faults, the associated execution times and reliability estimates are likely to be conservative. Experimental results using speci cations for NASA's planetary lander control software suggest that mutation-based testing could hold greater potential for enhancing reliability than the desirable but perhaps unachievable goal of independence among N versions. Nevertheless, some support for N-version enhancement of high quality, mutation-tested code is also o ered. Experimental results on data diversity, in which retry with a mutation-directed variation in input is attempted after system failure, suggest that mutation analysis could also be valuable in the design of fault-tolerant software systems.",88
Categorization of common coupling and its application to the maintainability of the Linux kernel,"Liguo Yu, Stephen R Schach, Kai Chen, Jeff Offutt",2004/10/4,Journal IEEE Transactions on Software Engineering,"Data coupling between modules, especially common coupling, has long been considered a source of concern in software design, but the issue is somewhat more complicated for products that are comprised of kernel modules together with optional nonkernel modules. This paper presents a refined categorization of common coupling based on definitions and uses between kernel and nonkernel modules and applies the categorization to a case study. Common coupling is usually avoided when possible because of the potential for introducing risky dependencies among software modules. The relative risk of these dependencies is strongly related to the specific definition-use relationships. In a previous paper, we presented results from a longitudinal analysis of multiple versions of the open-source operating system Linux. This paper applies the new common coupling categorization to version 2.4.20 of Linux, counting …",87
Improving logic-based testing,"Gary Kaminski, Paul Ammann, Jeff Offutt",2013/8/1,Journal Journal of Systems and Software,"Logic-based testers design tests from logical expressions that appear in software artifacts such as source code, design models, and requirements specifications. This paper presents three improvements to logic-based test design. First, in the context of mutation testing, we present fault hierarchies for the six relational operators. Applying the ROR mutation operator causes each relational operator to generate seven mutants per clause. The fault hierarchies show that only three of these seven mutants are needed. Second, we show how to bring the power of the ROR operator to logic-based test criteria such as the widely used Multiple Condition-Decision Coverage (MCDC) test criterion. Third, we present theoretical results supported by empirical data that show that the more recent coverage criterion of minimal-MUMCUT can find significantly more faults than MCDC. The paper has three specific recommendations: (1 …",85
Mutation Testing of Software Using MIMD Computer.,"A Jefferson Offutt, Roy P Pargas, Scott V Fichter, Prashant K Khambekar",1992/8/17,Conference ICPP (2),"Abstract {Mutation testing is a fault-based method for testing software that is computationally expensive. Mothra is an interpreter-based mutation testing system that is centered around an interpreter. This paper presents a parallel implementation of Mothra's interpreter on a MIMD machine. The parallel interpreter, HyperMothra, is implemented on a sixteen processor Intel iPSC/2 hypercube. Our goal was to demonstrate that the expense of software testing schemes such as mutation can be reduced by using parallel processing, and we demonstrate this by measuring the performance gains of the parallel interpreter over the Mothra interpreter. Results are presented using ten test programs, three different static work distribution schemes, and various numbers of processors. On our test programs, we found that our parallel interpreter achieved almost linear speedup over Mothra's sequential interpreter. With larger, faster high-performance computers available, mutation testing can be done at significantly less expense.",82
Automatic test data generation,Andrew Jefferson Offutt,1988,Publisher Georgia Institute of Technology,"This dissertation presents a completely automatable test data generation technique, constraint-based testing (CBT), that is based on test case adequacy. CBT has been implemented as part of the Mothra mutation system.",82
Criteria for testing polymorphic relationships,"Roger T Alexander, A Jefferson Offutt",2000/10/8,Conference Proceedings 11th International Symposium on Software Reliability Engineering. ISSRE 2000,"The emphasis in object oriented programs is on defining abstractions that have both state and behavior. This emphasis causes a shift in focus from software units to the way software components are connected. Thus, we are finding that we need less emphasis on unit testing and more on integration testing. The compositional relationships of inheritance and aggregation, especially when combined with polymorphism, introduce new kinds of integration faults. The paper presents results from an ongoing research project that has the goal of improving the quality of object oriented software. New testing criteria are introduced that take the effects of inheritance and polymorphism into account. These criteria are based on the new analysis technique of quasi-interprocedural data flow analysis. These testing criteria can improve the quality of object oriented software by ensuring that integration tests are high quality.",81
Subsumption of condition coverage techniques by mutation testing,"A Jefferson Offutt, Jeffrey M Voas",1996/1,"Journal Department of Information and Software Systems Engineering, George Mason University, Tech. Rep. ISSE-TR-96-100","Condition coverage testing is a family of testing techniques that are based on the logical flow of control through a program. The condition coverage techniques include a variety of requirements, including that each statement in the program is executed and that each branch is executed. Mutation testing is a fault-based testing technique that is widely considered to be very powerful, and that imposes requirements on testing that include, and go beyond, many other techniques. In this paper, we consider the six common condition coverage techniques, and formally show that these techniques are subsumed by mutation testing, in the sense that if mutation testing is satisfied, then the condition coverage techniques are also satisfied. The fact that condition coverage techniques are subsumed by mutation has immediate practical significance because the extensive research that has already been done for mutation can be used to support condition coverage techniques, including automated tools for performing mutation testing and generating test cases.",80
Deriving tests from software architectures,"Zhenyi Jin, Jeff Offutt",2001/11/27,Conference Proceedings 12th International Symposium on Software Reliability Engineering,"Software architectures are intended to describe essential high level structural and behavioral characteristics of a system. Architecture Description Languages (ADLs) describe these characteristics in ways that can be analyzed and manipulated algorithmically. This provides a unique opportunity for deriving tests at the system level. The paper defines formal testing criteria based on architecture relations, which are paths that architectural components use to communicate. The criteria have been applied to a specific ADL. Results from a comparative empirical study on industrial software are presented.",79
Integration testing of object‐oriented components using finite state machines,"Leonard Gallagher, Jeff Offutt, Anthony Cincotta",2006/12,"Journal Software Testing, Verification and Reliability","In object‐oriented terms, one of the goals of integration testing is to ensure that messages from objects in one class or component are sent and received in the proper order and have the intended effect on the state of the objects that receive the messages. This research extends an existing single‐class testing technique to integration testing of multiple classes. The single‐class technique models the behaviour of a single class as a finite state machine, transforms the representation into a data flow graph that explicitly identifies the definitions and uses of each state variable of the class, and then applies conventional data flow testing to produce test case specifications that can be used to test the class. This paper extends those ideas to inter‐class testing by developing flow graphs, finding paths between pairs of definitions and uses, detecting some infeasible paths and automatically generating tests for an arbitrary …",76
Test case generation for mutation-based testing of timeliness,"Robert Nilsson, Jeff Offutt, Jonas Mellin",2006/10/31,Journal Electronic Notes in Theoretical Computer Science,"Temporal correctness is crucial for real-time systems. Few methods exist to test temporal correctness and most methods used in practice are ad-hoc. A problem with testing real-time applications is the response-time dependency on the execution order of concurrent tasks. Execution order in turn depends on execution environment properties such as scheduling protocols, use of mutual exclusive resources as well as the point in time when stimuli is injected. Model based mutation testing has previously been proposed to determine the execution orders that need to be verified to increase confidence in timeliness. An effective way to automatically generate such test cases for dynamic real-time systems is still needed. This paper presents a method using heuristic-driven simulation to generate test cases.",76
Open-source change logs,"Kai Chen, Stephen R Schach, Liguo Yu, Jeff Offutt, Gillian Z Heller",2004/9,Journal Empirical Software Engineering,"A recent editorial in Empirical Software Engineering suggested that open-source software projects offer a great deal of data that can be used for experimentation. These data not only include source code, but also artifacts such as defect reports and update logs. A common type of update log that experimenters may wish to investigate is the ChangeLog, which lists changes and the reasons for which they were made. ChangeLog files are created to support the development of software rather than for the needs of researchers, so questions need to be asked about the limitations of using them to support research. This paper presents evidence that the ChangeLog files provided at three open-source web sites were incomplete. We examined at least three ChangeLog files for each of three different open-source software products, namely, GNUJSP, GCC-g++, and Jikes. We developed a method for counting …",75
Input parameter modeling for combination strategies,"Mats Grindal, Jeff Offutt",2007/2/13,Journal Proceedings of the 25th conference on IASTED International Multi-Conference: Software Engineering,"Combination strategies are test methods that generate test cases based on input parameter models. This paper suggests a structured modeling method used to translate requirements expressed in a general format into an input parameter model suitable for combination strategies. This paper also describes results from two initial experiments exploring the efficiency and effectiveness of the modeling method. These results indicate that the resulting models may contain enough information to detect the vast majority of faults in the system under test. Further, results indicate that the modeling method is simple enough to use in practical testing.",73
How strong is weak mutation?,"A Jefferson Offutt, Stephen D Lee",1991/10/1,"Book Proceedings of the symposium on Testing, analysis, and verification","Mutation testing is a fault-based technique for unit level testing of software. Weak mutation was proposed as a way to reduce the expense of mutation testing. Unfortunately, weak mutation is also expected to provide a weaker test of the software than mutation testing. This paper presents results from an implementation of weak mutation, where we compared the effectiveness versus the efficiency of weak mutation. Additionally, we examined several options in an attempt to find the most appropriate way to implement weak mutation. Our results indicate that weak mutation can be applied in a manner that is almost as effective as mutation testing, and with significant computational savings.",73
Test oracle strategies for model-based testing,"Nan Li, Jeff Offutt",2016/8/2,Journal IEEE Transactions on Software Engineering,"Testers use model-based testing to design abstract tests from models of the system's behavior. Testers instantiate the abstract tests into concrete tests with test input values and test oracles that check the results. Given the same test inputs, more elaborate test oracles have the potential to reveal more failures, but may also be more costly. This research investigates the ability for test oracles to reveal failures. We define ten new test oracle strategies that vary in amount and frequency of program state checked. We empirically compared them with two baseline test oracle strategies. The paper presents several main findings. (1) Test oracles must check more than runtime exceptions because checking exceptions alone is not effective at revealing failures. (2) Test oracles do not need to check the entire output state because checking partial states reveals nearly as many failures as checking entire states. (3) Test oracles do …",71
Applying mutation testing to web applications,"Upsorn Praphamontripong, Jeff Offutt",2010/4/6,"Conference 2010 Third International Conference on Software Testing, Verification, and Validation Workshops","As our awareness of the complexities inherent in web applications grows, we find an increasing need for more sophisticated ways to test them. Many web application faults are a result of how web software components interact; sometimes client-server and sometimes server-server. This paper presents a novel solution to the problem of integration testing of web applications by using mutation analysis. New mutation operators are defined, a tool (webMuJava) that implements these operators is presented, and results from a case study applying the tool to test a small web application are presented. The results show that mutation analysis can help create tests that are effective at finding web application faults, as well as indicating several directions for improvement.",71
Description of method-level mutation operators for java,"Yu-Seung Ma, Jeff Offutt",2005/11/29,"Journal Electronics and Telecommunications Research Institute, Korea, Tech. Rep","This document provides a brief description of method-level mutation operators for Java used by muJava. When designing method-level mutation operators for Java, we followed the selective approach [1]. The selective results found that the traditional operatorso of modifying operands and statements give little effectiveness to mutation testing. Therefore, we only consider mutation operators that modify expression by replacing, deleting, and inserting primitive operators. muJava provides six kinds of primitive operators;(1) arithmetic operator,(2) relational operator,(3) conditional operator,(4) shift operator,(5) logical operator, and (6) assignment. For some of them, muJava provides short-cut operators. This section presents designs of mutation operators for those six kinds of primitive operators. We try to design mutation operators that replace, insert, and delete the primitive operators. We defined total 12 method-level …",70
An integrated automatic test data generation system,A Jefferson Offutt,1991/11/25,Journal Journal of Systems Integration,"The Godzilla automatic test data generator is an integrated collection of tools that implements a relatively new test data generation method—constraint-based testing—that is based on mutation analysis. Constraint-based testing integrates mutation analysis with several other testing techniques, including statement coverage, branch coverage, domain perturbation, and symbolic evaluation. Because Godzilla uses a rule-based approach to generate test data, it is easily extendible to allow new testing techniques to be integrated into the current system. This article describes the system that has been built to implement constraint-based testing Godzilla’s design emphasizes orthogonality and modularity, allowing relatively easy extensions. Godzilla’s internal structure and algorithms are described with emphasis on internal structures of the system and the engineering problems that were solved during the …",68
Maintaining Evolving Component-Based Software with UML.,"Ye Wu, Jeff Offutt",2003/3/1,Conference CSMR,"Component-based software engineering is increasingly being adopted for software development. This approach relies on using reusable components as the building blocks for constructing software. On the one hand, this helps improve software quality and productivity; on the other hand, it necessitates frequent maintenance activities. The cost of maintenance for conventional software can account for as much as two-thirds of the total cost, and it is likely to be more for component-based software.",67
Evaluation of three specification-based testing criteria,"Aynur Abdurazik, Paul Ammann, Wei Ding, Jeff Offutt",2000/9/11,Conference Proceedings sixth IEEE international conference on engineering of complex computer systems. ICECCS 2000,"This paper compares three specification-based testing criteria using Mathur and Wong's PROBSUBSUMES measure. The three criteria are specification-mutation coverage, full predicate coverage, and transition-pair coverage. A novel aspect of the work is that each criterion is encoded in a model checker, and the model checker is used first to generate test sets for each criterion and then to evaluate test sets against alternate criteria. Significantly, the use of the model checker for generation of test sets eliminates human bias from this phase of the experiment. The strengths and weaknesses of the criteria are discussed.",66
Designing deletion mutation operators,"Marcio Eduardo Delamaro, Jeff Offutt, Paul Ammann",2014/3/31,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation","As a test criterion, mutation analysis is known for yielding very effective tests. It is also known for creating many test requirements, each of which is represented by a ""mutant"" that must be ""killed."" In recent years, researchers have found that these test requirements have a lot of duplication, in that many test requirements yield the same tests. Put another way, hundreds of mutants can usually be killed by only a few dozen tests. If we could reduce this duplication without reducing mutation's effectiveness, mutation testing could become more cost-effective. One avenue of this research has been to use only one type of mutant, the statement deletion mutation operator. Researchers have found that statement deletion mutation has relatively few mutants, but yields tests that are almost as effective as using all mutants, with the significant benefit that fewer equivalent mutants are generated. This paper extends this idea by …",63
Towards mutation analysis of android apps,"Lin Deng, Nariman Mirzaei, Paul Ammann, Jeff Offutt",2015/4/13,"Conference 2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Android applications (apps) have the highest number of releases, purchases, and downloads among mobile apps. However, quality is a known problem, and hence there is significant research interest in better methods for testing Android apps. We identify three reasons to extend mutation testing to Android apps. First, current testing approaches for Android apps use simple coverage criteria such as statement coverage; extending mutation coverage to Android apps promises more sophisticated testing. Second, testing researchers inventing other test methods for Android apps need to evaluate the quality of their test selection strategies, which mutation excels at. Finally, some approaches to test generation for Android apps, specifically combinatorial testing approaches, generate very large numbers of tests. This is particularly problematic because running Android tests is slow. For these reasons, this paper proposes …",62
A systematic literature review of techniques and metrics to reduce the cost of mutation testing,"Alessandro Viola Pizzoleto, Fabiano Cutigi Ferrari, Jeff Offutt, Leo Fernandes, Márcio Ribeiro",2019/11/1,Source Journal of Systems and Software,"Historically, researchers have proposed and applied many techniques to reduce the cost of mutation testing. It has become difficult to find all techniques and to understand the cost-benefit tradeoffs among them, which is critical to transitioning this technology to practice. This paper extends a prior workshop paper to summarize and analyze the current knowledge about reducing the cost of mutation testing through a systematic literature review. We selected 175 peer-reviewed studies, from which 153 present either original or updated contributions. Our analysis resulted in six main goals for cost reduction and 21 techniques. In the last decade, a growing number of studies explored techniques such as selective mutation, evolutionary algorithms, control-flow analysis, and higher-order mutation. Furthermore, we characterized 18 metrics, with particular interest in the number of mutants to be executed, test cases required …",61
Barriers to usable security? Three organizational case studies,"Deanna D Caputo, Shari Lawrence Pfleeger, M Angela Sasse, Paul Ammann, Jeff Offutt, Lin Deng",2016/10/25,Journal IEEE Security & Privacy,"Usable security assumes that when security functions are more usable, people are more likely to use them, leading to an improvement in overall security. Existing software design and engineering processes provide little guidance for leveraging this in the development of applications. Three case studies explore organizational attempts to provide usable security products.",61
Static analysis of mutant subsumption,"Bob Kurtz, Paul Ammann, Jeff Offutt",2015/4/13,"Conference 2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Mutation analysis generates a large set of variants, or mutants, and then demands a test set that distinguishes each variant from the original artifact. It has long been apparent that many mutants contribute little, if anything, to the subsequent test set. Researchers have developed various approaches to separate valuable mutants from redundant mutants. The notion of subsumption underlies several such approaches. Informally, one mutant subsumes another if tests that kill the first also kill the second. Computing subsumption relations is, not surprisingly, undecidable. Recent work formalized the notion of a mutant subsumption graph (MSG) and showed that root nodes in the MSG precisely identify mutants that are not redundant. To address the decidability issue, we first defined the dynamic subsumption graph as an approximation to the MSG. This paper continues by showing how symbolic execution can be used to …",60
An approach to fault modeling and fault seeding using the program dependence graph,"Mary Jean Harrold, A Jefferson Offutt, Kanupriya Tewary",1997/3/1,Journal Journal of Systems and Software,"We present a fault-classification scheme and a fault-seeding method that are based on the manifestation of faults in the program dependence graph (PDG). We enhance the domain/computation fault classification scheme developed by Howden to further characterize faults as structural and statement-level depending on the differences between the PDG for the original program and the PDG for the faulty program. We perform transformations on the PDG to produce the different types of faults described in our PDG-based fault-classification scheme. To demonstrate the usefulness of our technique, we implemented a fault seeder to embed faults in C programs. Our fault seeder makes controlled fault transformations to the PDG for a C program, and generates C code from the transformed PDG. The current version of the fault seeder creates multiple fault-seeded versions of the original program, each with one known fault …",60
A Fortran 77 interpreter for mutation analysis,"AJ Offutt VI, Kim N King",1987/7/1,Conference ACM SIGPLAN Notices,"Mutation analysis is a powerful technique for testing software systems. In the Mothra project, conducted at Georgia Tech's Software Engineering Research Center, mutation analysis is used as a basis for building an integrated software testing environment. Mutation analysis requires the execution of many slightly differing versions of the same program to evaluate the quality of the data used to test the program. In the current version of the Mothra system, a program to be tested is translated to intermediate code, where it and its mutated versions are executed by an interpreter.In this paper, we discuss some of the unique requirements of an interpreter used in a mutation-based testing environment. We then describe how these requirements affected the design and implementation of the Fortran 77 version of the Mothra interpreter. Other topics covered include the architecture of the interpreter and many of the design …",58
Experimental evaluation of SDL and one-op mutation for C,"Marcio Eduardo Delamaro, Lin Deng, Vinicius Humberto Serapilha Durelli, Nan Li, Jeff Offutt",2014/3/31,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation","Mutation analysis modifies a program by applying syntactic rules, called mutation operators, systematically to create many versions of the program (mutants) that differ in small ways. Testers then design tests to cause the mutants to behave differently from the original program. Mutation testing is widely considered to result in very effective tests, however, it is also quite costly. Cost comes from the many mutants that are created, the number of tests that are needed to kill the mutants, and the difficulty of deciding whether mutants behave equivalently to the original program. One-op mutation theorizes that cost can be reduced by using a single, very powerful, mutation operator that leads to tests that are almost as effective as if all operators are used. Previous research proposed the statement deletion operator (SDL) and found promising results. This paper investigates the use of SDL-mutation in a new context, the …",57
On the testing maturity of software producing organizations,"Mats Grindal, Jeff Offutt, Jonas Mellin",2006/8/29,Conference Testing: Academic & Industrial Conference-Practice And Research Techniques (TAIC PART'06),"This paper presents data from a study of the current state of practice of software testing. Test managers from twelve different software organizations were interviewed. The interviews focused on the amount of resources spent on testing, how the testing is conducted, and the knowledge of the personnel in the test organizations. The data indicate that the overall test maturity is low. Test managers are aware of this but have trouble improving. One problem is that the organizations are commercially successful, suggesting that products must already be ""good enough"". Also, the current lack of structured testing in practice makes it difficult to quantify the current level of maturity and thereby articulate the potential gain from increasing testing maturity to upper management and developers",56
Testing object-oriented software using the category-partition method,"A Jefferson Offutt, Alisa Irvine",1995/8,Journal 17th International Conference on Technology of Object-Oriented Languages and Systems,"When migrating from conventional to object-oriented programming, developers face di cult decisions in modifying their development process to best use the new technology. In particular, ensuring that the software is highly reliable in this new environment poses different challenges and developers need to understand effective ways to test the software. Much previous work in testing OO software has focused on developing new techniques and procedures. We ask whether existing techniques can work, and present empirical data that show that the existing technique of category-partition testing can effectively find faults in object-oriented software, and new techniques may not be needed. For this study, we identified types of faults that are common to C++ software and inserted faults of these types into two C++ programs. Test cases generated using the category-partition method were used to test the programs. A fault was considered detected if it caused the program to terminate abnormally or if the output was different from the output of the original program. The results show that the combination of the category-partition method and",56
Mutation testing implements grammar-based testing,"Jeff Offutt, Paul Ammann, Lisa Liu",2006/11/7,Conference Second Workshop on Mutation Analysis (Mutation 2006-ISSRE Workshops 2006),"This paper presents an abstract view of mutation analysis. Mutation was originally thought of as making changes to program source, but similar kinds of changes have been applied to other artifacts, including program specifications, XML, and input languages. This paper argues that mutation analysis is actually a way to modify any software artifact based on its syntactic description, and is in the same family of test generation methods that create inputs from syntactic descriptions. The essential characteristic of mutation is that a syntactic description such as a grammar is used to create tests. We call this abstract view grammar-based testing, and view it as an interface, which mutation analysis implements. This shift in view allows mutation to be defined in a general way, yielding three benefits. First, it provides a simpler way to understand mutation. Second, it makes it easier to develop future applications of mutation …",54
Using coupling-based weights for the class integration and test order problem,"Aynur Abdurazik, Jeff Offutt",2009/8/1,Journal The Computer Journal,"During component-based and object-oriented software development, software classes exhibit relationships that complicate integration, including method calls, inheritance and aggregation. Classes are integrated and tested in specific orders, where each class is added and tested one by one to see if it integrates successfully. A difficulty arises when cyclic dependencies exist—the functionality that is used by the first class to be tested must be mimicked by creating ‘stubs’ (sometimes called ‘mock objects’), an expensive and error-prone operation. This problem is generally called the class integration and test order (CITO) problem, and solutions must fully be automated for integration and testing to proceed smoothly and efficiently. This paper describes new techniques and algorithms to solve the CITO problem. New results include improved edge weights to more precisely model the cost of stubbing, and the use of …",53
A comparative evaluation of tests generated from different UML diagrams,"Supaporn Kansomkeat, Jeff Offutt, Aynur Abdurazik, Andrea Baldini",2008/8/6,"Conference 2008 Ninth ACIS International Conference on Software Engineering, Artificial Intelligence, Networking, and Parallel/Distributed Computing","This paper presents a single project experiment on the fault revealing capabilities of model-based test sets. The tests are generated from UML statecharts and UML sequence diagrams. This experiment found that the statechart test sets did better at revealing unit level faults than the sequence diagram test sets, and the sequence diagram test sets did better at revealing integration level faults than the statechart test sets. The statecharts also resulted in more test cases than the sequence diagrams. The results show that model-based testing can be used to systematically generate test data and indicates that different UML models can play different roles in testing.",51
Generating test cases from UML activity diagrams using the Condition-Classification Tree Method,"Supaporn Kansomkeat, Phachayanee Thiket, Jeff Offutt",2010/10/3,Conference 2010 2nd International conference on software technology and engineering,"A key technical challenge in software testing is the design of useful test cases. Test design can be based on a variety of software artifacts, including requirements, designs, or even the implementation. The Unified Modeling Language (UML) is now widely used to describe object-oriented designs. This paper focuses on one UML diagram, the activity diagram, which is used to model software behavior. This paper proposes the Condition-Classification Tree Method for generating test cases from activity diagrams. Activity diagrams are used to generate condition-classification trees, which are then used to create test case tables and test cases. The paper presents experimental data that show the proposed method can help generate a relatively small number of test cases at reasonable cost, early in development.",48
Quantitatively measuring object-oriented couplings,"Jeff Offutt, Aynur Abdurazik, Stephen R Schach",2008/12,Journal Software Quality Journal,"One key to several quality factors of software is the way components are connected. Software coupling can be used to estimate a number of quality factors, including maintainability, complexity, and reliability. Object-oriented languages are designed to reduce the number of dependencies among classes, which encourages separation of concerns and should reduce the amount of coupling. At the same time, the object-oriented language features change the way the connections are made, how they must be analyzed, and how they are measured. This paper discusses software couplings based on object-oriented relationships between classes, specifically focusing on types of couplings that are not available until after the implementation is completed, and presents a static analysis tool that measures couplings among classes in Java packages. Data from evaluating the tool on several open-source projects are …",47
Scalability issues with using FSMWeb to test web applications,"Anneliese A Andrews, Jeff Offutt, Curtis Dyreson, Christopher J Mallery, Kshamta Jerath, Roger Alexander",2010/1/1,Journal Information and Software Technology,"Web applications are fast becoming more widespread, larger, more interactive, and more essential to the international use of computers. It is well understood that web applications must be highly dependable, and as a field we are just now beginning to understand how to model and test Web applications. One straightforward technique is to model Web applications as finite state machines. However, large numbers of input fields, input choices and the ability to enter values in any order combine to create a state space explosion problem. This paper evaluates a solution that uses constraints on the inputs to reduce the number of transitions, thus compressing the FSM. The paper presents an analysis of the potential savings of the compression technique and reports actual savings from two case studies.",45
Coupling-based class integration and test order,"Aynur Abdurazik, Jeff Offutt",2006/5/23,Book Proceedings of the 2006 international workshop on Automation of software test,"During component-based and object-oriented software development, software classes exhibit relationships that complicate integration, including method calls, inheritance, and aggregation. When classes are integrated and tested, an order of integration must be established. The difficulty arises when cyclic dependencies exist - the functionality that is used by the first class to be tested must be mimicked by creating ""stubs"" (sometimes called ""mocks""), an expensive and error-prone operation. This problem is generally called the class integration and test order (CITO) problem, and solutions must be fully automated for integration and testing to proceed smoothly and efficiently. This paper describes new techniques and algorithms to solve the CITO problem. New results include improved edge weights that are derived from quantitative coupling measures to more precisely model the cost of stubbing, and the use of …",45
Better predicate testing,"Gary Kaminski, Paul Ammann, Jeff Offutt",2011/5/23,Book Proceedings of the 6th International Workshop on Automation of Software Test,"Mutation testing is widely recognized as being extremely powerful, but is considered difficult to automate enough for practical use. This paper theoretically addresses two possible reasons for this: the generation of redundant mutants and the lack of integration of mutation analysis with other test criteria. By addressing these two issues, this paper brings an important mutation operator, relational-operator-replacement (ROR), closer to practical use. First, we develop fault hierarchies for the six relational operators, each of which generates seven mutants per clause. These hierarchies show that, for any given clause, only three mutants are necessary. This theoretical result can be integrated easily into mutation analysis tools, thereby eliminating generation of 57% of the ROR mutants. Second, we show how to bring the power of the ROR operator to the widely used Multiple Condition-Decision Coverage (MCDC) test …",43
Recognizing authors: an examination of the consistent programmer hypothesis,"Jane Huffman Hayes, Jeff Offutt",2010/12,"Journal Software Testing, Verification and Reliability","Software developers have individual styles of programming. This paper empirically examines the validity of the  consistent programmer hypothesis: that a facet or set of facets exist that can be used to recognize the author of a given program based on programming style. The paper further postulates that the programming style means that different test strategies work better for some programmers (or programming styles) than for others. For example, all‐edges adequate tests may detect faults for programs written by Programmer A better than for those written by Programmer B. This has several useful applications: to help detect plagiarism/copyright violation of source code, to help improve the practical application of software testing, and to help pursue specific rogue programmers of malicious code and source code viruses. This paper investigates this concept by experimentally examining whether particular facets of …",42
Handling constraints in the input space when using combination strategies for software testing,"Mats Grindal, Jeff Offutt, Jonas Mellin",2006,Publisher Institutionen för kommunikation och information,"This study compares seven different methods for handling constraints in input parameter models when using combination strategies to select test cases. Combination strategies are used to select test cases based on input parameter models. An input parameter model is a representation of the input space of the system under test via a set of parameters and values for these parameters. A test case is one specific combination of values for all the parameters. Sometimes the input parameter model may contain parameters that are not independent. Some sub-combinations of values of the dependent parameters may not be valid, ie, these subcombinations do not make sense. Combination strategies, in their basic forms, do not take into account any semantic information. Thus, invalid sub-combinations may be included in test cases in the test suite.",42
Better algorithms to minimize the cost of test paths,"Nan Li, Fei Li, Jeff Offutt",2012/4/17,"Conference 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation","Model-based testing creates tests from abstract models of the software. These models are often described as graphs, and test requirements are defined as sub paths in the graphs. As a step toward creating concrete tests, complete (test) paths that include the sub paths through the graph are generated. Each test path is then transformed into a test. If we can generate fewer and shorter test paths, the cost of testing can be reduced. The minimum cost test paths problem is finding the test paths that satisfy all test requirements with the minimum cost. This paper presents new algorithms to solve the problem, and then presents data from an empirical comparison. The algorithms adapt approximation algorithms for the shortest super string problem. The comparison is with an existing tool that uses a brute force approach to extend each sub path to a complete path. One new algorithm is based on the greedy set-covering …",40
Comparison of unit-level automated test generation tools,"Shuang Wang, Jeff Offutt",2009/4/1,"Conference 2009 International Conference on Software Testing, Verification, and Validation Workshops","Data from projects worldwide show that many software projects fail and most are completed late or over budget. Unit testing is a simple but effective technique to improve software in terms of quality, flexibility, and time-to-market. A key idea of unit testing is that each piece of code needs its own tests and the best person to design those tests is the developer who wrote the software. However, generating tests for each unit by hand is very expensive, possibly prohibitively so. Automatic test data generation is essential to support unit testing and as unit testing is achieving more attention, developers have a greater need for automated unit test data generation tools. However, developers have very little information about which tools are effective. This experiment compared three well-known public-accessible unit test data generation tools, JCrasher, TestGen4j, and JUB. We applied them to Java classes and evaluated them …",39
Integration testing based on software couplings,"Zhenyi Jin, A Jefferson Offutt",1995/6/25,"Conference Computer Assurance, 1995. COMPASS'95.'Systems Integrity, Software Safety and Process Security'. Proceedings of the Tenth Annual Conference on","Integration testing is an important part of the testing process, but few integration testing techniques have been systematically studied or defined. This paper presents an integration testing technique based on couplings between software components. The coupling-based testing technique is described, and 12 coverage criteria are defined. The coupling-based technique is also compared with the category-partition method on a case study, which found that the coupling-based technique detected more faults with fewer test cases than category-partition. This modest result indicates that the coupling-based testing approach can benefit practitioners who are performing integration testing on software. While it is our intention to develop algorithms to fully automate this technique, it is relatively easy to apply by hand.",39
Mutation at system and functional levels,"Pedro Reales Mateo, Macario Polo Usaola, Jeff Offutt",2010/4/6,"Conference 2010 Third International Conference on Software Testing, Verification, and Validation Workshops","Mutation analysis has been applied to many testing problems, including functional programs in numerous languages, specifications, network protocols, web services, and security policies. Program mutation, where mutation analysis is applied to programs, has been applied to the unit level (functions and methods), integration of pairs of functions, and individual classes. However, program mutation has not been applied to the problem of testing multiple classes or entire software programs, that is, there is no system level mutation. This paper introduces a project on the problem of multi-class and system level mutation testing. The technical differences between using mutation to test single classes and multiple classes are explored, and new system level mutation operators are defined. A new execution style for detecting killed mutants, Flexible Weak Mutation, is introduced. A support tool, Bacterio, is currently under …",38
Input validation analysis and testing,"Jane Huffman Hayes, Jeff Offutt",2006/12,Journal Empirical Software Engineering,"This research addresses the problem of statically analyzing input command syntax as defined in interface and requirements specifications and then generating test cases for dynamic input validation testing. The IVAT (Input Validation Analysis and Testing) technique has been developed, a proof-of-concept tool (MICASA) has been implemented, and a case study validation has been performed. Empirical validation on large-scale industrial software (from the Tomahawk Cruise Missile) shows that as compared with senior, experienced analysts and testers, MICASA found more syntactic requirement specification defects, generated test cases with higher syntactic coverage, and found additional defects. The experienced analysts found more semantic defects than MICASA, and the experienced testers’ cases found 7.4 defects per test case as opposed to an average of 4.6 defects found by MICASA test cases …",38
"Maintainability of the kernels of open-source operating systems: A comparison of Linux with FreeBSD, NetBSD, and OpenBSD","Liguo Yu, Stephen R Schach, Kai Chen, Gillian Z Heller, Jeff Offutt",2006/6/1,Journal Journal of Systems and Software,"We compared and contrasted the maintainability of four open-source operating systems: Linux, FreeBSD, NetBSD, and OpenBSD. We used our categorization of common coupling in kernel-based software to highlight future maintenance problems. An unsafe definition is a definition of a global variable that can affect a kernel module if that definition is changed. For each operating system we determined a number of measures, including the number of global variables, the number of instances of global variables in the kernel and overall, as well as the number of unsafe definitions in the kernel and overall. We also computed the value of each our measures per kernel KLOC and per KLOC overall. For every measure and every ratio, Linux compared unfavorably with FreeBSD, NetBSD, and OpenBSD. Accordingly, we are concerned about the future maintainability of Linux.",38
Quality impacts of clandestine common coupling,"Stephen R Schach, Bo Jin, David R Wright, Gillian Z Heller, Jeff Offutt",2003/7,Journal Software Quality Journal,"The increase in maintenance of software and the increased amounts of reuse are having major positive impacts on the quality of software, but are also introducing some rather subtle negative impacts on the quality. Instead of talking about existing problems (faults), developers now discuss “potential problems,” that is, aspects of the program that do not affect the quality initially, but could have deleterious consequences when the software goes through some maintenance or reuse. One type of potential problem is that of common coupling, which unlike other types of coupling can be clandestine. That is, the number of instances of common coupling between a module M and the other modules can be changed without any explicit change to M. This paper presents results from a study of clandestine common coupling in 391 versions of Linux. Specifically, the common coupling between each of 5332 kernel …",37
Increased software reliability through input validation analysis and testing,"Jane Huffman Hayes, A Jefferson Offutt",1999/11/1,Conference Proceedings 10th International Symposium on Software Reliability Engineering (Cat. No. PR00443),"The input validation testing (IVT) technique has been developed to address the problem of statically analyzing input command syntax as defined in an English textual interface and requirements specifications and then generating test cases for input validation testing. The technique does not require design or code, so it can be applied early in the life cycle. A proof-of-concept tool has been implemented and validation has been performed. Empirical validation on industrial software shows that the IVT method found more requirements specification defects than senior testers, generated test cases with higher syntactic coverage than senior testers, and found defects that were not found by the test cases of senior testers. Additionally, the tool performed at a much-reduced cost.",37
Analysis techniques for testing polymorphic relationships,"Roger T Alexander, A Jefferson Offutt",1999/8/5,Conference Proceedings of Technology of Object-Oriented Languages and Systems-TOOLS 30 (Cat. No. PR00278),"As we move from developing procedure oriented to object oriented programs, the complexity traditionally found in functions and procedures is moving to the connections among components. More faults occur as components are integrated to form higher level aggregates of behavior and state. Consequently, we need to place more effort on testing the connections among components. Although object oriented technology provides abstraction mechanisms to build components to integrate, it also adds new compositional relations that can contain faults, which must be found during integration testing. The paper describes new techniques for analyzing and testing the polymorphic relationships that occur in object oriented software. The application of these techniques can result in an increased ability to find faults and overall higher quality software.",37
Are we there yet? How redundant and equivalent mutants affect determination of test completeness,"Bob Kurtz, Paul Ammann, Jeff Offutt, Mariet Kurtz",2016/4/11,"Source 2016 IEEE Ninth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Mutation score has long been used in research as a metric to measure the effectiveness of testing strategies. This paper presents evidence that mutation score lacks the desired accuracy to determine the completeness of a test suite due to noise introduced by the redundancy inherent in traditional mutation, and that dominator mutation score is a superior metric for this purpose. We evaluate the impact of different levels of redundant and equivalent mutants on mutation score and the ability to determine completeness in developing a mutation-adequate test suite. We conclude that, in the context of our model, redundant mutants make it very difficult to accurately assess test completeness. Equivalent mutants, on the other hand, have little effect on determining completeness. Based on this information, we suggest limits to redundancy and equivalency that mutation tools must achieve to be practical for general use in …",36
An analysis of OO mutation operators,"Jingyu Hu, Nan Li, Jeff Offutt",2011/3/21,"Conference 2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops","This paper presents results from empirical studies using object-oriented, class-level mutation operators. Class mutation operators modify OO programming language features such as inheritance, polymorphism, dynamic binding and encapsulation. Most previous empirical studies of mutation operators used statement-level operators, this study asked questions about the static and dynamic nature of class-level mutation operators. Results include statistics on the various types of mutants, how many are equivalent, new rules for avoiding creation of equivalent mutants, the difficulty of killing individual mutants, and the difficulty of killing mutants from the various operators. The paper draws conclusions about which mutation operators are more or less useful, leading to recommendations about how future OO mutation systems should be built.",36
Generating test cases from UML specifications,"Aynur Abdurazik, Jeff Offutt",1999/10,Pages 416-429,"Uni ed Modeling Language (UML) is a third generation modeling language in objectoriented software engineering. It provides constructs to specify, construct, visualize, and document artifacts of software-intensive systems.",36
Is bytecode instrumentation as good as source code instrumentation: An empirical study with industrial tools (experience report),"Nan Li, Xin Meng, Jeff Offutt, Lin Deng",2013/11/4,Conference 2013 IEEE 24th International Symposium on Software Reliability Engineering (ISSRE),"Branch coverage (BC) is a widely used test criterion that is supported by many tools. Although textbooks and the research literature agree on a standard definition for BC tools measure BC in different ways. The general strategy is to “instrument” the program by adding statements that count how many times each branch is taken. But the details for how this is done can influence the measurement for whether a set of tests have satisfied BC. For example, the standard definition is based on program source, yet some tools instrument the bytecode to reduce computation cost. A crucial question for the validity of these tools is whether bytecode instrumentation gives results that are the same as, or at least comparable to, source code instrumentation. An answer to this question will help testers decide which tool to use. This research looked at 31 code coverage tools, finding four that support branch coverage. We chose one …",33
Managing conflicts when using combination strategies to test software,"Mats Grindal, Jeff Offutt, Jonas Mellin",2007/4/10,Conference 2007 Australian Software Engineering Conference (ASWEC'07),"Testers often represent systems under test in input parameter models. These contain parameters with associated values. Combinations of parameter values, with one value for each parameter, are potential test cases. In most models, some values of two or more parameters cannot be combined. Testers must then detect and avoid or remove these conflicts. This paper proposes two new methods for automatically handling such conflicts and compares these with two existing methods, based on the sizes of the final conflict-free test suites. A test suite reduction method, usable with three of the four investigated methods is also included in the study, resulting in seven studied conflict handling methods. In the experiment, the number and types of conflicts, as well as the size of the input parameter model and the coverage criterion used, are varied. All in all, 3854 test suites with a total of 929,158 test cases were generated …",33
Mutation-based testing criteria for timeliness,"Robert Nilsson, Jeff Offutt, Sten F Andler",2004/9/28,"Conference Proceedings of the 28th Annual International Computer Software and Applications Conference, 2004. COMPSAC 2004.","Temporal correctness is crucial to the dependability of real-time systems. Few methods exist to test for temporal correctness and most existing methods are ad-hoc. A problem with testing real-time applications is the dependency on the execution time and execution order of individual tasks. Thus, the response times for the tasks may be non-deterministic with respect to inputs. Conventional test coverage criteria ignore task interleaving and tinting and, thus do not help determine which execution orders need to be exercised to test for temporal correctness. This paper presents test criteria based on mutation to test timeliness. We also show how previously proposed methods in specification based testing, can be applied to testing real-time systems",33
"Teaching software testing: Experiences, lessons learned and the path forward","W Eric Wong, Antonia Bertolino, Vidroha Debroy, Aditya Mathur, Jeff Offutt, Mladen Vouk",2011/5/22,Conference 2011 24th IEEE-CS Conference on Software Engineering Education and Training (CSEE&T),"According to a study commissioned by the National Institute of Standards and Technology in 2002, software bugs cost the U.S. economy an estimated $59.5 billion annually, or about 0.6 percent of the nation's gross domestic product (GDP). The same study also found that more than one-third of these costs, or an estimated $22.2 billion, could be eliminated by an improved testing infrastructure. These numbers would be significantly higher if the study were conducted today.",31
A logic mutation approach to selective mutation for programs and queries,"Garrett Kaminski, Upsorn Praphamontripong, Paul Ammann, Jeff Offutt",2011/10/1,Journal Information and Software Technology,"Program mutation testing is a technique for measuring and generating high quality test data. However, traditional mutation operators are not necessarily efficient or effective. We address three specific issues. One, test data that kills all mutants generated by current mutation tools can still miss detection of some common logic faults because such tools lack appropriate logic mutation operators. Two, the number of mutants generated is often unnecessarily large. Three, many equivalent mutants can be generated and these can be difficult to eliminate.",29
The adherence of open source Java programmers to standard coding practices,"Mahmoud Omar Elish, Jeff Offutt",2002,Pages 193-198,"The use of agreed-upon coding practices is believed to enhance program comprehension, which directly affects reuse and maintainability. This paper describes a controlled small-scale experiment that tries to determine how well open source Java programmers adhere to a set of well publicized coding practices. The experiment evaluated 100 arbitrarily selected open source Java classes from different programmers with respect to 16 standard coding practices. The results of this experiment indicate that open source Java programmers do not always adhere to standard coding practices. It was found that only 4% of the subject classes have no violations to any of the 16 standard coding practices and there were only 5 of 16 coding practices that all subjects followed. It was also found that there are positive correlations between the number of violations found in a class and its lines-of-code, number of methods, and number of attributes.",29
An analysis tool for coupling-based integration testing,"A Jefferson Offutt, Aynur Abdurazik, Roger T Alexander",2000/9/11,Conference Proceedings Sixth IEEE International Conference on Engineering of Complex Computer Systems. ICECCS 2000,"This research is part of a project to develop practical, effective, formalizable, automatable techniques for integration testing. Integration testing is an important part of the testing process, but few integration testing techniques have been systematically studied or defined. This paper discusses the design and implementation of an analysis tool for measuring the amount of coverage achieved by a set of test data according to a set of previously defined coupling criteria. This tool can be used to support integration testing of software components. The coupling-based testing technique, which has been described elsewhere, is summarized, and coverage algorithms are discussed. The focus of this paper is on the instrumentation techniques and an analysis tool built for Java programs. It was built in Java using the general Java parser JavaCC and the Java Tree Builder (JTB). We are currently using this tool to gather …",28
An empirical analysis of test oracle strategies for model-based testing,"Nan Li, Jeff Offutt",2014/3/31,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation","Model-based testing is a technique to design abstract tests from models that partially describe the system's behaviour. Abstract tests are transformed into concrete tests, which include test input values, expected outputs, and test oracles. Although test oracles require significant investment and are crucial to the success of the testing, we have few empirical results about how to write them. With the same test inputs, test oracles that check more of the program state have the potential to reveal more failures, but may also cost more to design and create. This research defines six new test oracle strategies that check different parts of the program state different numbers of times. The experiment compared the six test oracle strategies with two baseline test oracle strategies. The null test oracle strategy just checks whether the program crashes and the state invariant test oracle strategy checks the state invariants in the model …",27
Putting the engineering into software engineering education,Jeff Offutt,2013/1/3,Journal IEEE software,"Based on over 20 years of teaching and research experience, the author provides his assessment of software engineering education. He then builds on the analysis to provide recommendations on how we need to diverge from computer science to increase our impact, gain credibility, and ultimately ensure the success and recognition of our young discipline. A key behind the author's message is that we need to become a true engineering discipline.",27
An industrial case study of structural testing applied to safety-critical embedded software,"Jing Guan, Jeff Offutt, Paul Ammann",2006/9/21,Book Proceedings of the 2006 ACM/IEEE international symposium on Empirical software engineering,"Effective testing of safety-critical real-time embedded software is difficult and expensive. Many companies are hesitant about the cost of formalized criteria-based testing and are not convinced of the benefits. This paper presents the results of an industrial case study that compared the normal testing at a company (manual functional testing) with testing based on the logic-based criterion of correlated active clause coverage (CACC). The evaluation was performed during the testing of embedded, real-time control software that has been deployed in a safety-critical application in the transportation industry. We found in our study that the test cases generated to satisfy the CACC criterion detected major safety-critical faults that were not detected by functional testing. We also found that the cost required for CACC testing was not necessarily higher than the cost of functional testing. There were also several faults that were …",27
Coupling-based Testing of OO Programs.,"Roger T Alexander, A Jefferson Offutt",2004/4,Journal J. Univers. Comput. Sci.,"As we move from developing procedure-oriented to OO programs, the complexity traditionally found in functions and procedures is moving to the connections among components. More faults occur as components are integrated to form higher level aggregates. Consequently, we need to place more effort on testing the connections among components. Although OO technology provides abstraction mechanisms to build components to integrate, it also adds new compositional relations that can contain faults, which must be found during integration testing. This paper describes new techniques for analyzing and testing the polymorphic relationships that occur in OO software. The application of these techniques can result in an increased ability to find faults and overall higher quality software.",27
Web software applications quality attributes,Jeff Offutt,2002/11,Journal Quality Engineering in Software Technology (CONQUEST 2002),"In only four or five years, the World Wide Web has changed from a static collection of HTML web pages to a dynamic engine that powers e-commerce, collaborative work, and distribution of information and entertainment. These exciting changes have been fueled by changes in software technology, the software development process, and how software is deployed. Although the word “heterogeneous” is commonly used to describe web software, we might easily forget to notice in how many ways it can be applied. In fact, the synonymous term “diverse” is more general and familiar, and may be more appropriate. Web software applications use diverse types of hardware, they include a diverse collection of types of implementation languages (including traditional programs, HTML, interpreted scripts, and databases), they are composed of software written in diverse languages, and they are built by collections of people with very diverse sets of skills.",27
Description of class mutation mutation operators for java,"Yu-Seung Ma, Jeff Offutt",2005/11/7,"Journal Electronics and Telecommunications Research Institute, Korea","This document provides a brief description of the muJava class mutation operators, which were updated currently for version II of the tool. The class mutation operators are classified into four groups, based on the language features that are affected. The first three groups are based on language features that are common to all OO languages. The last group includes OO features that are Java-specific.",26
Fault detection capabilities of coupling-based oo testing,"Roger T Alexander, Jeff Offutt, JM Biemann",2002/11/12,"Conference 13th International Symposium on Software Reliability Engineering, 2002. Proceedings.","Object-oriented programs cause a shift in focus from software units to the way software classes and components are connected. Thus, we are finding that we need less emphasis on unit testing and more on integration testing. The compositional relationships of inheritance and aggregation, especially when combined with polymorphism, introduce new kinds of integration faults, which can be covered using testing criteria that take the effects of inheritance and polymorphism into account. This paper demonstrates, via a set of experiments, the relative effectiveness of several coupling-based OO testing criteria and branch coverage. OO criteria are all more effective at detecting faults due to the use of inheritance and polymorphism than branch coverage.",25
A scalable big data test framework,"Nan Li, Anthony Escalona, Yun Guo, Jeff Offutt",2015/4/13,"Conference 2015 IEEE 8th international conference on software testing, verification and validation (ICST)","This paper identifies three problems when testing software that uses Hadoop-based big data techniques. First, processing big data takes a long time. Second, big data is transferred and transformed among many services. Do we need to validate the data at every transition point? Third, how should we validate the transferred and transformed data? We are developing a novel big data test framework to address these problems. The test framework generates a small and representative data set from an original large data set using input space partition testing. Using this data set for development and testing would not hinder the continuous integration and delivery when using agile processes. The test framework also accesses and validates data at various transition points when data is transferred and transformed.",24
Mutation at the multi-class and system levels,"Pedro Reales Mateo, Macario Polo Usaola, Jeff Offutt",2013/4/1,Journal Science of Computer Programming,"Mutation analysis has been applied to many testing problems, including numerous programming languages, specifications, network protocols, web services, and security policies. Program mutation, where mutation analysis is applied to programs, has been applied to the unit level (functions and methods), integration of pairs of functions, and individual classes. However, program mutation has not been applied to the problem of integration testing of multiple classes or entire software programs; thus, there is no system level mutation. This paper introduces a project on the problem of integration testing of multiple classes (multi-class) and system level mutation testing. The technical differences between using mutation to test single classes and multiple classes are explored, and new system level mutation operators are defined. A new execution style for detecting killed mutants, flexible weak mutation, is introduced. A …",24
A controlled experimental evaluation of test cases generated from UML diagrams,"Aynur Abdurazik, Jeff Offutt, Andrea Baldini",2004/5,"Journal Technicalc report, George Mason University","This paper presents a single project experiment on the fault revealing capabilities of test sets that are generated from UML statecharts and sequence diagrams. The results of this experiment show that the statechart test sets do better at revealing unit level faults than the sequence diagram test sets, and the sequence diagram test sets do better at revealing integration level faults than the statechart test sets. The experimental data also show that the statecharts result in more test cases than the sequence diagrams. The experiment showed that UML diagrams can be used in generating test data systematically, and different UML diagrams can play different roles in testing.",24
A model-based testing technique for component-based real-time embedded systems,"Jing Guan, Jeff Offutt",2015/4/13,"Conference 2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","The growing complexity of modern real-time embedded systems is leading to increased use of component-based software engineering (CBSE) technology. Although many ideas have been proposed for building component-based real-time embedded software, techniques for testing component-based realtime systems are scarce. The challenges not only come from the integration of different types of components through their interfaces but also include the composition of extra-functional properties. In an embedded system, extra-functional requirements are as important as functional requirements. A real-time embedded system needs to achieve its functionality under the constraints caused by its extra-functional properties. Correct functional behavior with regard to timing properties is essential to real-time embedded system. This paper focuses on real-time requirements instead of all extra-functional requirements …",22
Test Sequence Generation For Integration Testing Of Component Software,"Leonard Gallagher, Jeff Offutt",2009/8/1,Journal The Computer Journal,"Ensuring high object interoperability is a goal of integration testing for object-oriented (OO) software. When messages are sent, objects that receive them should respond as intended. Ensuring this is especially difficult when software uses components that are developed by different vendors, in different languages, and the implementation sources are not all available. A finite state machines model of inter-operating OO classes was presented in a previous paper. The previous paper presented details of the method and empirical results from an automatic tool. This paper presents additional details about the tool itself, including how test sequences are generated, how several difficult problems were solved and the introduction of new capabilities to help automate the transformation of test specifications into executable test cases. Although the test method is not 100% automated, it represents a fresh approach to …",22
Coverage criteria for state based specifications,"Paul Ammann, Jeff Offutt, Wuzhi Xu",2008,"Journal Formal Methods and Testing: An Outcome of the FORTEST Network, Revised Selected Papers","Test engineers often face the task of developing a set of test cases that are appropriate for a given software artefact. The software testing literature is replete with testing methods tailored to the various specification, design, and implementation methods used in software engineering. This chapter takes a novel inverted view. Instead of starting with the specific artefact at hand, we identify two general sets of coverage criteria – one based on graphs and the other based on predicates. We then ask two questions with respect to the specific artefact under test: (1) What graphs are suitable abstractions of the artefact for the purpose of testing? (2) What predicates should be extracted from this artefact for the purpose of testing? Combining the answers to these two questions with the standard graph-based and logic-based coverage criteria yields test requirements. The test engineer can then proceed to identify test …",22
A systematic review of cost reduction techniques for mutation testing: preliminary results,"Fabiano Cutigi Ferrari, Alessandro Viola Pizzoleto, Jeff Offutt",2018/4/9,"Source 2018 IEEE international conference on software testing, verification and validation workshops (ICSTW)","This paper reports on results from a systematic review that characterizes the state-of-the-art on cost reduction for mutation testing. It analyzes the evolution of research on this topic and its underlying goals and techniques, and identifies metrics used to measure cost reduction. The mixed search strategy used automatic search, snowballing, and a survey of authors of primary studies. The analysis is based on a set of 165 peer-reviewed studies, from which 146 present either original or updated approaches and results for cost reduction of mutation testing. A list of 6 main goals for cost reduction is presented, and 22 techniques were identified. Historically, 18 metrics have been used to measure the gains and losses observed in experimental studies. In the last decade, substantial growth in the number of published studies was observed, particularly among techniques such as selective mutation, evolutionary algorithms …",21
Is mutation analysis effective at testing android apps?,"Lin Deng, Jeff Offutt, David Samudio",2017/7/25,"Conference 2017 IEEE International Conference on Software Quality, Reliability and Security (QRS)","Not only is Android the most widely used mobile operating system, more apps have been released and downloaded for Android than for any other OS. However, quality is an ongoing problem, with many apps being released with faults, sometimes serious faults. Because the structure of mobile app software differs from other types of software, testing is difficult and traditional methods do not work. Thus we need different approaches to test mobile apps. In this paper, we identify challenges in testing Android apps, and categorize common faults according to fault studies. Then, we present a way to apply mutation testing to Android apps. Additionally, this paper presents results from two empirical studies on fault detection effectiveness using open-source Android applications: one for Android mutation testing, and another for four existing Android testing techniques. The studies use naturally occurring faults as well as …",21
Automated testing of timeliness: A case study,"Robert Nilsson, Jeff Offutt",2007/5/20,Conference Second International Workshop on Automation of Software Test (AST'07),A problem with testing timeliness of real-time applications is the response-time dependency on the execution order of concurrent tasks. Conventional test methods ignore task interleaving and timing and thus do not help determine which execution orders need to be exercised to test temporal correctness. Model based mutation testing has been proposed to generate inputs and determine the execution orders that need to be verified to increase confidence in timeliness. This paper evaluate a mutation-based framework for automated testing of timeliness by applying it on a small control system running on Linux/RTAI. The experiments presented in this paper indicate that mutation-based test cases are more effective than random and stress tests in finding both naturally occurring and randomly seeded timeliness faults.,21
Syntactic fault patterns in oo programs,"Roger T Alexander, Jeff Offutt, James M Bieman",2002/12/2,"Conference Eighth IEEE International Conference on Engineering of Complex Computer Systems, 2002. Proceedings.","Although program faults are widely studied, there are many aspects of faults that we still do not understand, particularly about OO software. In addition to the simple fact that one important goal during testing is to cause failures and thereby detect faults, a full understanding of the characteristics of faults is crucial to several research areas. The power that inheritance and polymorphism brings to the expressiveness of programming languages also brings a number of new anomalies and fault types. In prior work we presented a fault model for the appearance and realization of OO faults that are specific to the use of inheritance and polymorphism. Many of these faults cannot appear unless certain syntactic patterns are used. The patterns are based on language constructs, such as overriding methods that directly define inherited state variables and non-inherited methods that call inherited methods. If one of these syntactic …",21
On the nonmaintainability of open-source software,"Stephen R Schach, A Jefferson Offutt",2002/5,Journal Proceedings of the 2nd Workshop on Open Source Software Engineering,"A major strength of open-source software is that the source code is open to scrutiny by anyone who chooses to examine it. Accordingly, it is reasonable to assume that the quality of opensource software will be higher than that of closed-source software. After all, closed-source software is examined by only a limited number of individuals, all of whom are paid to do so. It seems equally reasonable to conclude that open-source software is superior to closed-source software in other ways as well, including maintainability. Again, the argument is that the scrutiny by a large number of volunteers leads to a better product. On the other hand, the fact that open-source software is a product of an amorphous group of individuals, rather than a hierarchical development team, means that there is no single person who is in charge of an open-source software product. As a result, modifications can be made to an individual module that could have a deleterious effect on the maintainability of the opensource software product as a whole. An example of this is the introduction of common coupling into an open-source software product.",21
Experimental results of automatically generated adequate test sets,"RA DeMillo, AJ Offutt",1988/9,Journal Proceedings of the Sixth Annual Pacific Northwest Software Quality Conference,,21
An experimental evaluation of web mutation operators,"Upsorn Praphamontripong, Jeff Offutt, Lin Deng, JingJing Gu",2016/4/11,"Conference 2016 IEEE Ninth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","While modern web development technologies enhance the capabilities of web applications, they introduce challenges for testers. This paper introduces, evaluates, and refines web mutation operators that target interaction faults in web applications. An experimental study is conducted on 11 subject web applications using 15 web mutation operators. The effectiveness of 12 independently developed test sets are analyzed in terms of how well they kill web mutants. Web mutation adequate tests are compared with independently created test sets to evaluate the web mutation operators. Tests designed to satisfy the web mutation testing criterion provide 100% coverage while the tests designed to satisfy traditional testing criteria provide, on average, 47%coverage. The paper also analyzes which mutants and mutation operators the traditional tests had difficulty killing. We found that some types of mutants that are not …",20
Testing coupling relationships in object‐oriented programs,"Roger T Alexander, Jeff Offutt, Andreas Stefik",2010/12,"Journal Software Testing, Verification and Reliability","As we move toward developing object‐oriented (OO) programs, the complexity traditionally found in functions and procedures is moving to the connections among components. Different faults occur when components are integrated to form higher‐level structures that aggregate the behavior and state. Consequently, we need to place more effort on testing the connections among components. Although OO technologies provide abstraction mechanisms for building components that can then be integrated to form applications, it also adds new compositional relations that can contain faults. This paper describes techniques for analyzing and testing the polymorphic relationships that occur in OO software. The techniques adapt traditional data flow coverage criteria to consider definitions and uses among state variables of classes, particularly in the presence of inheritance, dynamic binding, and polymorphic overriding of …",19
"Impact of release intervals on empirical research into software evolution, with application to the maintainability of Linux","Lawrence G Thomas, Stephen R Schach, Gillian Z Heller, Jeff Offutt",2009/2/1,Journal IET software,"In most empirical research on software evolution, analysis of the data is performed with respect to the release sequence number (RSN), rather than the release date. This distinction is important when the intervals between release dates vary widely, as is generally the case with open-source software. A widely cited study on the maintainability of Linux was published in this journal in 2002. The study showed that, whereas the size of the Linux kernel grew linearly with respect to the RSN, the amount of common coupling grew exponentially. In view of the adverse effect of common coupling on maintainability, the conclusion drawn there was that Linux needed to be refactored with minimal common coupling. Here, it is shown that, if the same data are analysed with respect to the release date, the amount of common coupling grows linearly; hence, there is no need to refactor Linux to promote maintainability. The authors …",19
An integrated system for automatically generating test data,A Jefferson Offutt,1990/4/23,Conference Systems Integration'90. Proceedings of the First International Conference on Systems Integration,"A description is given of the Godzilla automatic test data generator, an integrated set of tools that implements a new test data generation method, constraint-based testing, that is based on mutation analysis. Constraint-based testing integrates mutation analysis with several other testing techniques, such as statement analysis, branch coverage, and data flow analysis. Because Godzilla uses a rule-based approach to generate adequate test data, it is easily extendible to allow new testing techniques to be integrated into the current system. The system that has been built to implement constraint-based testing is described. Godzilla was designed in an object-oriented fashion that emphasized orthogonality and modularity. Godzilla is described from a practical viewpoint with emphasis on the internal structure of the system and the engineering problems that were solved during the implementation.< >",19
Anatomy of a software engineering project,"Catherine L Bullard, Inez Caldwell, James Harrell, Cis Hinkle, A Jefferson Offutt",1988/2/1,Conference ACM SIGCSE Bulletin,"This paper discusses a complete software development project carried out in a one quarter undergraduate software engineering course. The project was the design and implementation of a complete system by 25 students. They worked in smaller groups on four functionally separate subsystems that were successfully integrated into a complete system. This was accomplished by using five advanced students to manage the groups, real users to criticize each step of the process, and UNIX tools to implement the subsystems. This paper describes the project, presents the methodologies used, and discusses both the positive and negative aspects of this course. It concludes by presenting a set of recommendations based on our experience with this project.",19
Growing a reduced set of mutation operators,"Marcio Eduardo Delamaro, Lin Deng, Nan Li, Vinicius Durelli, Jeff Offutt",2014/9/28,Conference 2014 Brazilian Symposium on Software Engineering,"Although widely considered to be quite powerful, mutation testing is also known for its expense. Three fundamental (and related) sources for much of the expense are (1) the number of mutants, (2) the number of equivalent mutants, and (3) the number of test cases needed to kill the mutants. Recent results have shown that mutation systems create a significant number of mutants that are killed by the same tests. These mutants can be considered to be “redundant,” in the sense that if N mutants are killed by the same test, only one of those mutants is truly needed. Selective mutation, one-op mutation, and random mutant selection are ways to choose a “reduced” set of mutation operators that will help testers design tests that are almost as effective, as measured by running the tests against the complete set of mutants. This paper presents a novel procedure for choosing a reduced set of mutation operators based on a …",18
Evasive bots masquerading as human beings on the web,"Jing Jin, Jeff Offutt, Nan Zheng, Feng Mao, Aaron Koehl, Haining Wang",2013/6/24,Conference 2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN),"Web bots such as crawlers are widely used to automate various online tasks over the Internet. In addition to the conventional approach of human interactive proofs such as CAPTCHAs, a more recent approach of human observational proofs (HOP) has been developed to automatically distinguish web bots from human users. Its design rationale is that web bots behave intrinsically differently from human beings, allowing them to be detected. This paper escalates the battle against web bots by exploring the limits of current HOP-based bot detection systems. We develop an evasive web bot system based on human behavioral patterns. Then we prototype a general web bot framework and a set of flexible de-classifier plugins, primarily based on application-level event evasion. We further abstract and define a set of benchmarks for measuring our system's evasion performance on contemporary web applications …",18
A computer algebra system for nonassociative identities,"D Pokrass Jacobs, Sekhar V Muddana, A Jefferson Offutt",1993,"Journal Proceedings of the Fifth Internationl Conference on Hadronic Mechanics and Nonpotential Interactions”(HC Myung, Ed.), Nova Science Publishers, Inc., New York","In recent years there has been an emergence of general purpose computer algebra systems such as Maple, Macsyma, Mathematica, and Reduce. These systems provide a wealth of facilities for performing symbolic algebraic computation. Many are capable of computing a Gröbner bases of the ideal generated by a set of multivariate polynomials. Such systems work well at manipulating polynomials in variables that commute and associate. The reader is referred to Caviness [3] for more on these computer systems. To our knowledge, however, little work has been done toward an interactive computer system specifically for performing nonassociative algebraic computation. The purpose of this paper is to describe an initial attempt at building a specialized, but useful, system for doing nonassociative algebra. We should remark that the application of computers to nonassociative algebra is not new. An example of very early work is by Kleinfeld [10], and two books [2, 12] contain many papers on such work. However these computer solutions have usually been aimed at solving a unique problem with a very particular solution. Most often, the resulting program could not be easily reused for other similar problems. Our system is called Albert. In this paper we will describe its capabilities, briefly discuss its implementation, and then discuss some typical computations that Albert has performed.",18
Introduction to software testing,"Paul Ammann, Jeff Offutt",2016/12/13,Publisher Cambridge University Press,"This extensively classroom-tested text takes an innovative approach to explaining software testing that defines it as the process of applying a few precise, general-purpose criteria to a structure or model of the software. The book incorporates cutting-edge developments, including techniques to test modern types of software such as OO, web applications, and embedded software. This revised second edition significantly expands coverage of the basics, thoroughly discussing test automaton frameworks, and it adds new, improved examples and numerous exercises. The theory of coverage criteria is carefully and cleanly explained to help students understand concepts before delving into practical applications, while extensive use of the JUnit test framework gives students practical experience in a test framework popular in the industry. Exercises, meanwhile, feature specifically tailored tools that allow students to check their own work. The book's website also offers an instructor's manual, PowerPoint slides, testing tools for students, and example software programs in Java.",2476
Automatically testing interacting software components,"Leonard Gallagher, Jeff Offutt",2006/5/23,Book Proceedings of the 2006 international workshop on Automation of software test,"One goal of integration testing for object-oriented software is to ensure high object interoperability. Sent messages should have the intended effects on the states and subsequent actions of the receiving objects. This is especially difficult when software is comprised of components developed by different vendors, with different languages, and the implementation sources are not all available. A previous paper presented a model of inter-operating OO classes based on finite state machines. It addresses methods for identifying the relevant actions of a test component to be integrated into the system, transforms the finite state specification into a control and data flow graph, labels the graph with all defs and uses of class variables, and presents an algorithm to generate test specifications as specific paths through the directed graph. It also presents empirical results from an automatic tool that was built to support this test …",17
Coupling-based integration testing,"Zhenyi Jin, A Jefferson Offutt",1996/10/21,Conference Proceedings of ICECCS'96: 2nd IEEE International Conference on Engineering of Complex Computer Systems (held jointly with 6th CSESAW and 4th IEEE RTAW),"Integration testing is an important part of the testing process, but few integration testing techniques have been systematically studied or defined. This paper presents an integration testing technique based on couplings between software components. The coupling-based testing technique is described, and coverage criteria for three types of 12 coupling levels are defined. This technique can be used to support integration testing of software components, and satisfies part of the FAA's requirements for structural coverage analysis of software.",17
Albert user's guide,"David Pokrass Jacobs, Sekhar V Muddana, AJ Offut, D Lee, T Whiteley",1993,"Journal Department of Computer Science, Clemson University","Albert is an interactive research tool to assist the specialist in the study of nonassociative algebras. This document serves as a technical guide to Albert. We refer the reader to [JMO] for a more casual tutorial†. The main problem addressed by Albert is the recognition of polynomial identities. Roughly, Albert works in the following way. Suppose a user wishes to study alternative algebras. These are algebras defined by the two polynomial identities (yx) x− y (xx) and (xx) y− x (xy), known respectively as the right and left alternative laws. In particular, the user wishes to know if, in the presence of the right and left alternative laws,(a, b, c)◦[a, b] is also an identity. Here (a, b, c) denotes (ab) c− a (bc),[a, b] denotes ab− ba, and x◦ y denotes xy+ yx. The user first supplies Albert with the right and left alternative laws, using the identity command. Next, the user supplies the problem type. This refers to the number and degree of letters in the target polynomial. For example, in this problem, each term of the target polynomial has two a’s, two b’, and one c, and so the problem type is 2a2b1c. This is entered using the generators command. It may be that over certain fields of scalars the polynomial is an identity, but over others it is not an identity. Albert allows the user to supply the field of scalars, but currently the user must select either a Galois field GF (p) in which p is a prime less than 263− 1, or the field of rational numbers Q‡. This is done using the field command. If no field is entered, the default field GF (251) is chosen.",17
Using symbolic execution to aid automatic test data generation,"A Jefferson Offutt, E Jason Seaman",1990/6/25,"Conference Computer Assurance, 1990. COMPASS'90,'Systems Integrity, Software Safety and Process Security'., Proceedings of the Fifth Annual Conference on","It is shown how symbolic execution is used to solve the internal variable problem in the Godzilla test data generator. In constraint-based testing, which is used by the system, the internal variable problem appears when the constraints that specify the test cases contain internal variables. The necessary background is developed by describing the constraint systems used by Godzilla and by discussing symbolic execution in general terms. The application of symbolic execution to the internal variable problem is presented. The discussion focuses on the software used, including algorithmic details. Following this, a practical example of using this system to detect a fault in a small program is presented.< >",17
Using mutation to design tests for aspect-oriented models,"Birgitta Lindström, Jeff Offutt, Daniel Sundmark, Sten F Andler, Paul Pettersson",2017/1/1,Journal Information and Software Technology,"Context: Testing for properties such as robustness or security is complicated because their concerns are often repeated in many locations and muddled with the normal code. Such “cross-cutting concerns” include things like interrupt events, exception handling, and security protocols. Aspect-oriented (AO) modeling allows developers to model the cross-cutting behavior independently of the normal behavior, thus supporting model-based testing of cross-cutting concerns. However, mutation operators defined for AO programs (source code) are usually not applicable to AO models (AOMs) and operators defined for models do not target the AO features.",16
Generating test data from requirements/specifications: Phase II final report,AJ Offutt,1999/1,"Publisher Technical Report ISE-TR-99-01, Department of Information and Software Engineering, George Mason University, Fairfax VA, January 1999, http://www. ise. gmu. edu/techrep",,15
Description of mujava’s method-level mutation operators,"Yu-Seung Ma, Jeff Offutt",2016/7,Journal Update,"This document provides a brief description of method-level mutation operators for Java used by muJava. When designing method-level mutation operators for Java, we followed the selective approach [3]. The selective results found that the traditional operatorso of modifying operands and statements give little effectiveness to mutation testing. Therefore, we only consider mutation operators that modify expression by replacing, deleting, and inserting primitive operators. muJava provides six kinds of primitive operators;(1) arithmetic operator,(2) relational operator,(3) conditional operator,(4) shift operator,(5) logical operator, and (6) assignment. For some of them, muJava provides short-cut operators. This section presents designs of mutation operators for those six kinds of primitive operators. We try to design mutation operators that replace, insert, and delete the primitive operators. We defined total 12 method-level operators in Table 1. The detailed description for the operators are described in the following subsections, according to each primitive operator.",14
A test automation language framework for behavioral models,"Nan Li, Jeff Offutt",2015/4/13,"Conference 2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Model-based testers design tests in terms of models, such as paths in graphs. This results in abstract tests, which have to be converted to concrete tests because the abstract tests use names and events that exist in the model, but not the implementation. Model elements often appear in many abstract tests, so testers write the same redundant code many times. However, many existing model-based testing techniques are very complicated to use in practice, especially in agile software development. Thus, testers usually have to transform abstract tests to concrete tests by hand. This is time-consuming, labor-intensive, and error-prone. This paper presents a language to automate the creation of mappings from abstract tests to concrete tests. Three issues are addressed: (1) creating mappings and generating test values, (2) transforming graphs and using coverage criteria to generate test paths, and (3) solving constraints …",14
Toward harnessing high-level language virtual machines for further speeding up weak mutation testing,"Vinicius HS Durelli, Jeff Offutt, Marcio E Delamaro",2012/4/17,"Conference 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation","High-level language virtual machines (HLL VMs) are now widely used to implement high-level programming languages. To a certain extent, their widespread adoption is due to the software engineering benefits provided by these managed execution environments, for example, garbage collection (GC) and cross-platform portability. Although HLL VMs are widely used, most research has concentrated on high-end optimizations such as dynamic compilation and advanced GC techniques. Few efforts have focused on introducing features that automate or facilitate certain software engineering activities, including software testing. This paper suggests that HLL VMs provide a reasonable basis for building an integrated software testing environment. As a proof-of-concept, we have augmented a Java virtual machine (JVM) to support weak mutation analysis. Our mutation-aware HLL VM capitalizes on the relationship …",14
Generating trace-sets for model-based testing,"Birgitta Lindstrom, Paul Pettersson, Jeff Offutt",2007/11/5,Conference The 18th IEEE International Symposium on Software Reliability (ISSRE'07),"Model-checkers are powerful tools that can find individual traces through models to satisfy desired properties. These traces provide solutions to a number of problems. Instead of individual traces, software testing needs sets of traces that satisfy coverage criteria. Finding a trace set in a large model is difficult because model checkers generate single traces and use a lot of memory. Space and time requirements of modelchecking algorithms grow exponentially with respect to the number of variables and parallel automata of the model being analyzed. We present a method that generates a set of traces by iteratively invoking a model checker. The method mitigates the memory consumption problem by dynamically building partitions along the traces. This method was applied to a testability case study, and it generated the complete trace set, while ordinary model-checking could only generate 26%.",14
Web application bypass testing,"Jeff Offutt, Ye Wu, Xaiochen Du, Hong Huang",2004/9/28,"Conference Proceedings of the 28th Annual International Computer Software and Applications Conference, 2004. COMPSAC 2004.","Input validation refers to checking user inputs to a program to ensure that they conform to expectations of the program. Input validation is used to check the format of numbers and strings, check the length of strings, and to ensure that strings do not contain invalid characters. Input validation testing (IVT) is particularly important for software that has a heavy reliance on user inputs, including Web applications. A common technique in Web applications is to perform input validation on the client by using HTML attributes and scripting languages such as JavaScript. An insidious problem with performing input validation on the client is that end users have the ability to bypass this validation. Bypass testing is a unique and novel way to create test cases that is available only because of the unusual mix of client-server, HTML GUI, and JavaScript technologies that are used in Web applications. This workshop paper presents the …",14
An empirical comparison of modularity of procedural and object-oriented software,"Lisa K Ferrett, Jeff Offutt",2002/12/2,"Conference Eighth IEEE International Conference on Engineering of Complex Computer Systems, 2002. Proceedings.",A commonly held belief is that applications written in object-oriented languages are more modular than those written in procedural languages. This paper presents results from an experiment that examines this hypothesis. Open source and industrial program modules written in the procedural languages of Fortran and C were compared with open source program modules written in the object-oriented languages of C++ and Java. The metrics examined in this study were lines of code per module and number of parameters per module. The results of the investigation support the hypothesis. The modules of the object-oriented programs were found to be half the size of those of the procedural programs and the average number of parameters per module for the object-oriented programs was approximately half that of the procedural programs. Thus the object-oriented programs were twice as modular as the procedural …,14
Analyzing software architecture descriptions to generate system-level tests,"Aynur Abdurazik, Zhenyi Jin, Liz White, Jeff Offutt",2000/5,Journal Workshop on Evaluating Software Architectural Solutions–2000,"As the size and complexity of software systems increase, problems stemming from the design and integration of overall system structure become more significant than problems stemming from the choice of algorithms and data structures. This is due not only to the increased amount of code, but also to the need to distribute the parts of the application and have them interact in complex and potentially novel ways. Future software systems can be expected to continue to grow in size and complexity, which will greatly strain our already questionable ability to develop software that is both functional and reliable. At least for the foreseeable future, software architecture and object-oriented design will continue to be used to facilitate this growth. Software architecture allows developers to abstract away the details of the individual components of an application, allowing them to be viewed as sets of components with associated connectors that describe the interactions between these components. One product of software architecture research has been a set of formal and semi-formal languages that provide behavioral descriptions of the components and connectors. These architecture description languages (ADLs) represent a significant opportunity for dealing with the issue of scale with respect to testing and analysis of software systems. Other researchers have looked into aspects of analysis and testing of software architectures, including developing integration test plans by using test criteria based on CHAM [3], dependence analysis techniques called chaining [6], and applying dependence analysis to problems in software maintenance [5]. We are currently …",14
Finding redundancy in web mutation operators,"Upsorn Praphamontripong, Jeff Offutt",2017/3/13,"Conference 2017 IEEE international conference on software testing, verification and validation workshops (ICSTW)","New web development technologies enhance functionality of web applications but also introduce challenges in testing the software. As mutation analysis has been shown to be effective at designing tests for traditional software, we previously proposed web mutation testing. However, applying mutation analysis can be computationally expensive due to an extensive number of test requirements. This paper introduces, evaluates, and refines web mutation operators with the goal of reducing the number of test requirements. This paper evaluates redundancy among web mutation operators by analyzing the types of mutants that can be killed by tests generated specifically to kill other types of mutants and the types of mutants (and the operators that generate them) that can be excluded from testing while maintaining the same level of fault detection. An experimental study was conducted on 12 subject web applications …",13
Adding criteria-based tests to test driven development,"William Shelton, Nan Li, Paul Ammann, Jeff Offutt",2012/4/17,"Conference 2012 IEEE Fifth International Conference on Software Testing, Verification and Validation","Test driven development (TDD) is the practice of writing unit tests before writing the source. TDD practitioners typically start with example-based unit tests to verify an understanding of the software's intended functionality and to drive software design decisions. Hence, the typical role of test cases in TDD leans more towards specifying and documenting expected behavior, and less towards detecting faults. Conversely, traditional criteria-based test coverage ignores functionality in favor of tests that thoroughly exercise the software. This paper examines whether it is possible to combine both approaches. Specifically, can additional criteria based tests improve the quality of TDD test suites without disrupting the TDD development process? This paper presents the results of an observational study that generated additional criteria-based tests as part of a TDD exercise. The criterion was mutation analysis and the additional …",13
An industrial case study of bypass testing on web applications,"Jeff Offutt, Qingxiang Wang, Joann Ordille",2008/4/9,"Conference 2008 1st International Conference on Software Testing, Verification, and Validation","Web applications are interactive programs that are deployed on the world wide Web. Their execution is usually controlled very heavily by user choices and user data. This makes them vulnerable to abnormal behavior from invalid inputs as well as security attacks. Thus, Web applications invest heavily in validating user inputs according to defined constraints on the values. This work focuses on validation done on the client, which uses two types of technologies; restrictions in HTML form fields and scripts that check values. Unfortunately users have the ability to subvert or skip client-side validation. Bypass testing has been developed to test the behavior of Web applications when client-side validation is skipped. This paper presents results from an industry case study of bypass testing applied to a project from Avaya Research Labs, NPP. The paper presents a process for designing, implementing, automating and …",13
The dynamic domain reduction approach for test data generation: Design and algorithms,"A Jefferson Offutt, Zhenyi Jin, Jie Pan",1994/9,"Journal George Mason University, Fairfax, Virginia, Technical Report ISSE-TR-94-110",,13
What to expect of predicates: An empirical analysis of predicates in real world programs,"Vinicius HS Durelli, Jeff Offutt, Nan Li, Marcio E Delamaro, Jin Guo, Zengshu Shi, Xinge Ai",2016/3/1,Journal Journal of Systems and Software,"One source of complexity in programs is logic expressions, i.e., predicates. Predicates define much of the functional behavior of the software. Many logic-based test criteria have been developed, including the active clause coverage (ACC) criteria and the modified condition/decision coverage (MCDC). The MCDC/ACC criteria is viewed as being expensive, which motivated us to evaluate the cost of applying these criteria using a basic proxy: the number of clauses. We looked at the frequency and percentage of predicates in 63 Java programs. Moreover, we also compared these Java programs with three programs in the safety-critical domain, in which logic-basic testing is often used. Although around 99% of the predicates within Java programs contain at most three clauses, there is a positive linear correlation between overall measures of size and the number of predicates that have more than three clauses …",12
Mutating aspect-oriented models to test cross-cutting concerns,"Birgitta Lindström, Sten F Andler, Jeff Offutt, Paul Pettersson, Daniel Sundmark",2015/4/13,"Conference 2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Aspect-oriented (AO) modeling is used to separate normal behaviors of software from specific behaviors that affect many parts of the software. These are called “cross-cutting concerns,” and include things such as interrupt events, exception handling, and security protocols. AO modeling allow developers to model the behaviors of cross-cutting concerns independently of the normal behavior. Aspect-oriented models (AOM) are then transformed into code by “weaving” the aspects (modeling the cross-cutting concerns) into all locations in the code where they are needed. Testing at this level is unnecessarily complicated because the concerns are often repeated in many locations and because the concerns are muddled with the normal code. This paper presents a method to design robustness tests at the abstract, or model, level. The models are mutated with novel operators that specifically target the features of AOM …",12
On the testing maturity of software producing organizations: Detailed data,"Mats Grindal, Jeff Offutt, Jonas Mellin",2006/7,Journal Technical Report ISE-TR-06–03,This paper presents data from a study of the current state of practice of software testing. Test managers from twelve different software organizations were interviewed. The interviews,12
Testing concurrent user behavior of synchronous web applications with Petri nets,"Jeff Offutt, Sunitha Thummala",2019/4/4,Journal Software & Systems Modeling,"Web applications are now used in every aspect of our lives to manage work, provide products and services, read email, and provide entertainment. The software technologies used to build web applications provide features that help designers provide flexible functionality, but that are challenging to model and test. In particular, the network-based request-response model of programming means that web applications are inherently “stateless” and implicitly concurrent. They are stateless because a new network connection is made for each request (for example, when a user clicks a submit button). Thus, the server does not, by default, recognize multiple requests from the same user. Web applications are also concurrent because multiple users can use the same web application at the same time, creating contention for the same resources. Unfortunately, most web application testing does not adequately …",11
A novel self-paced model for teaching programming,"Jeff Offutt, Paul Ammann, Kinga Dobolyi, Chris Kauffmann, Jaime Lester, Upsorn Praphamontripong, Huzefa Rangwala, Sanjeev Setia, Pearl Wang, Liz White",2017/4/12,Book Proceedings of the Fourth (2017) ACM Conference on Learning@ Scale,"The Self-Paced Learning Increases Retention and Capacity (SPARC) project is responding to the well-documented surge in CS enrollment by creating a self-paced learning environment that blends online learning, automated assessment, collaborative practice, and peer-supported learning. SPARC delivers educational material online, encourages students to practice programming in groups, frees them to learn material at their own pace, and allows them to demonstrate proficiency at any time. This model contrasts with traditional course offerings, which impose a single schedule of due dates and exams for all students. SPARC allows students to complete courses faster or slower at a pace tailored to the individual, thereby allowing universities to teach more students with the same or fewer resources. This paper describes the goals and elements of the SPARC model as applied to CS1. We present results so far and …",11
Increasing Class-Component Testability.,"Supaporn Kansomkeat, Jeff Offutt, Wanchai Rivepiboon",2005/2,Conference IASTED Conf. on Software Engineering,"Testability has many effects on software. In general, increasing testability makes detecting faults easier. However, increasing testability of third party software components is difficult because the source is usually not available. This paper introduces a method to increase component testability. This method helps a user test when the component is reused during integration. First, we analyze a component to gather definition and use information about method and class variables. Then, this information is used to increase component testability to support component testing. Increased testability helps to detect errors, and helps testers observe state variables and generate inputs for testing. This paper uses an example to report the effort (in terms of test cases) and effectiveness (in terms of killed mutants).",11
Testing web applications,"Anneliese Andrews, Jeff Offutt, Roger Alexander",2004,Journal Software and Systems Modeling,"The problem of how to effectively and efficiently generate test cases for web applications is completely open. This paper proposes a system-level testing technique that combines test generation based on finite state machines with constraints. We use a hierarchical approach to model potentially large web applications. The approach builds Finite State Machines (FSMs) that model subsystems of the web applications, and then generates test requirements as subsequences of states in the FSMs. These subsequences are then combined and refined to form complete executable tests. The constraints are used to select a reduced set of inputs with the goal of reducing the state space explosion otherwise inherent in using FSMS. The paper illustrates the technique with a running example of a web-based course student information system and introduces a prototype implementation to support the technique.",11
"Integrating research, reuse, and integration into software engineering courses","A Offutt, Roland Untch",1992,Journal Software Engineering Education,"This paper discusses a method for incorporating several important software engineering concepts that have been traditionally hard to teach into courses at both the undergraduate and graduate level. We have created a project template that can be instantiated in many ways to be tailored to the level of a particular course, the number of students, the quality of students, and the goals of the course. We consider a “large” software project to be one in which each programmer's contribution represents a small part of the overall project (less than 10%). Our project template is a completed software system, which, although too large for a semester project in its complete form, can be easily divided into coherent subsystems. The students are provided with some subsystems, and asked to derive requirements for, design, implement, and test the remaining subsystems. This approach allows the students to work in a large …",11
"An experimental comparison of edge, edge-pair, and prime path criteria","Vinicius HS Durelli, Marcio E Delamaro, Jeff Offutt",2018/1/15,Journal Science of Computer Programming,"Many criteria have been proposed to generate test inputs. Criteria are usually compared in terms of subsumption: if a criterion C1 subsumes C2, it is guaranteed that every test set that satisfies C1 will also satisfy C2. An implication of this notion of subsumption is that C1-adequate tests tend to find more faults than C2-adequate tests, but C1-adequate tests tend to be larger. Thus, while useful, the idea of subsumption does not elaborate on some practical properties of expensive criteria as, for instance, how many more faults a C1-adequate test set will find? More generally, what is the return on investment for choosing more expensive criteria?",10
A case study on bypass testing of web applications,"Jeff Offutt, Vasileios Papadimitriou, Upsorn Praphamontripong",2014/2,Journal Empirical Software Engineering,"Society’s increasing reliance on services provided by web applications places a high demand on their reliability. The flow of control through web applications heavily depends on user inputs and interactions, so user inputs should be thoroughly validated before being passed to the back-end software. Although several techniques are used to validate inputs on the client, users can easily bypass this validation and submit arbitrary data to the server. This can cause unexpected behavior, and even allow unauthorized access. A test technique called bypass testing intentionally sends invalid data to the server by bypassing client-side validation. This paper reports results from a comprehensive case study on 16 deployed, widely used, commercial web applications. As part of this project, the theory behind bypass testing was extended and an automated tool, AutoBypass, was built. The case study found failures in …",10
Using mutant stubbornness to create minimal and prioritized test sets,"Loreto Gonzalez-Hernandez, Birgitta Lindström, Jeff Offutt, Sten F Andler, Pasqualina Potena, Markus Bohlin",2018/7/16,"Conference 2018 IEEE International Conference on Software Quality, Reliability and Security (QRS)","In testing, engineers want to run the most useful tests early (prioritization). When tests are run hundreds or thousands of times, minimizing a test set can result in significant savings (minimization). This paper proposes a new analysis technique to address both the minimal test set and the test case prioritization problems. This paper precisely defines the concept of mutant stubbornness, which is the basis for our analysis technique. We empirically compare our technique with other test case minimization and prioritization techniques in terms of the size of the minimized test sets and how quickly mutants are killed. We used seven C language subjects from the Siemens Repository, specifically the test sets and the killing matrices from a previous study. We used 30 different orders for each set and ran every technique 100 times over each set. Results show that our analysis technique performed significantly better than prior …",9
Introduction to Software Testing Edition 2,"Paul Ammann, Jeff Offutt",2017,"Publisher Cambridge University Press, New York, NY","This document contains the work-in-progress solutions for the second edition of the text. The goal is to keep the solution manuals synchronized with the textbook so that there are no “TBD” solutions, as persisted in the first edition for many years. We distinguish between “student solutions” and “instructor only” for the convenience of both. Students can work homeworks then check their own answers. Instructors can assign homeworks with some confidence that students will do their own work instead of looking up the answer in the manual.",9
An industrial study of applying input space partitioning to test financial calculation engines,"Jeff Offutt, Chandra Alluri",2014/6,Journal Empirical Software Engineering,"This paper presents results from an industrial study that applied input space partitioning and semi-automated requirements modeling to large-scale industrial software, specifically financial calculation engines. Calculation engines are used in financial service applications such as banking, mortgage, insurance, and trading to compute complex, multi-conditional formulas to make high risk financial decisions. They form the heart of financial applications, and can cause severe economic harm if incorrect. Controllability and observability of these calculation engines are low, so robust and sophisticated test methods are needed to ensure the results are valid. However, the industry norm is to use pure human-based, requirements-driven test design, usually with very little automation. The Federal Home Loan Mortgage Corporation (FHLMC), commonly known as Freddie Mac, concerned that these test design …",8
Assessing the influence of multiple test case selection on mutation experiments,"Marcio E Delamaro, Jeff Offutt",2014/3/31,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation Workshops","Mutation testing is widely used in experiments. Some papers experiment with mutation directly, while others use it to introduce faults to measure the effectiveness of tests created by other methods. There is some random variation in the mutation score depending on the specific test values used. When generating tests to use in experiments, a common, although not universal practice, is to generate multiple sets of tests to satisfy the same criterion or according to the same procedure, and then to compute their average performance. Averaging over multiple test sets is thought to reduce the variation in the mutation score. This practice is extremely expensive when tests are generated by hand (as is common) and as the number of programs increase (a current positive trend in software engineering experimentation). The research reported in this short paper asks a simple and direct question: do we need to generate …",8
Using abstraction and Web applications to teach criteria-based test design,"Jeff Offutt, Nan Li, Paul Ammann, Wuzhi Xu",2011/5/22,Conference 2011 24th IEEE-CS Conference on Software Engineering Education and Training (CSEE&T),"The need for better software continues to rise, as do expectations. This, in turn, puts more emphasis on finding problems before software is released. Industry is responding by testing more, but many test engineers in industry lack a practical, yet theoretically sound, understanding of testing. Software engineering educators must respond by teaching students to test better. An essential testing skill is designing tests, and an efficient way to design high quality tests is to use an engineering approach: test criteria. To achieve the maximum benefit, criteria should be used during unit (developer) testing, as well as integration and system testing. This paper presents an in-depth teaching experience report on how we successfully teach criteria-based test design using abstraction and publicly accessible web applications. Our teaching materials are freely available online or upon request.",8
Web Application Testing Challenges,"Blaine Donley, Jeff Offutt",2009/9,"Journal Software Engineering, George Mason University","A website is a static collection of HTML files that are linked together through tags on the World Wide Web. A web application, however, is an arbitrarily complex program that happens to be deployed on the World Wide Web. Web applications use new technologies that change on a regular basis, are almost always distributed, often employ concurrency, are inherently component-based, usually built with diverse languages, and use control and state behaviors that are not available to traditional software. This paper explores the technological-based differences between web software applications and traditional applications, with a specific emphasis on how these differences affect testing. Both applied and research issues are considered.",8
Generating Test Data From Requirements,AJ Offutt,1999/11/24,"Journal Specifications: Phase III Final Report, George Mason University",,8
Software testing: from theory to practice,A Jefferson Offutt,1998/1,Journal IEEE aerospace and electronic systems magazine,"This paper is about the disparity between what is known and what is being learned in academia and what is being used in industry. The author believes there are many reasons. Some of these represent accidental and some essential problems. Most are part of a general issue of quality in the software products. Most problems that make it more difficult to apply testing techniques are part of a larger problem which make them more cost-effective to produce high quality software. The author presents a list of reasons industry does not use the highly advanced, and in some cases, highly developed software testing techniques that are available. The problems are divided into three broad categories: problems in industry; problems in academic research and education; and problems in the interface between the two.",8
An empirical analysis of blind tests,"Kesina Baral, Jeff Offutt",2020/10/24,"Conference 2020 IEEE 13th International Conference on Software Testing, Validation and Verification (ICST)","Modern software engineers automate as many tests as possible. Test automation allows tests to be run hundreds or thousands of times: hourly, daily, and sometimes continuously. This saves time and money, ensures reproducibility, and ultimately leads to software that is better and cheaper. Automated tests must include code to check that the output of the program on the test matches expected behavior. This code is called the test oracle and is typically implemented in assertions that flag the test as passing if the assertion evaluates to true and failing if not. Since automated tests require programming, many problems can occur. Some lead to false positives, where incorrect behavior is marked as correct, and others to false negatives, where correct behavior is marked as incorrect. This paper identifies and studies a common problem where test assertions are written incorrectly, leading to incorrect behavior that is not …",7
Exoneration-based fault localization for SQL predicates,"Yun Guo, Nan Li, Jeff Offutt, Amihai Motro",2019/1/1,Journal Journal of Systems and Software,"Spectrum-based fault localization (SFL) techniques automatically localize faults in program entities (statements, predicates, SQL clauses, etc.) by analyzing information collected from test executions. One application of SFL techniques is to find faulty SQL statements in database applications. However, prior techniques treated each SQL statement as one program entity, thus they could not find faulty elements inside SQL statements. Since SQL statements can be complex, identifying the faulty element within a faulty SQL statement is still time-consuming.",7
The journal impact factor,Jeff Offutt,2008/3,"Source Software Testing, Verification and Reliability","This issue contains three divergent papers. The first, Modular formal verification of specifications of concurrent systems, by Gradara, Santone, Vaglini, and Villani, proposes a bottom-up approach to verifying modular systems. Properties of components are first verified, then emergent properties of the system as a whole are verified. The approach is applied to a web service. The second paper, Simulated time for host-based testing with TTCN-3, by Blom, Deiss, Kontio, Rennoch, and Sidorova, describes a method to test real-time embedded software. When real-time software is tested in a development environment where the timing characteristics do not match the target environment, this research proposes using simulated time to test the real-time properties. The third paper, IPOG/IPOG-D: Efficient test generation for multi-way combinatorial testing, by Lei, Kacker, Kuhn, Okun, and Lawrence, presents two new strategies …",7
Why don't we publish more TDD research papers?,Jeff Offutt,2018/6,"Source Software Testing, Verification and Reliability","One of the most important changes in the software engineering industry over the last decade has been the emergence and growth of agile processes. The agile process that has the most effect on our field is test‐driven development (TDD), which is being adopted by more companies every week. TDD puts testing “front and center,” by using automated tests to replace functional requirements. TDD asks the engineer to define initial behavior of software with a test case. Each automated TDD test includes input values and a desired response encoded in an assertion. The desired response, or behavior, replaces the test oracle in more traditional tests. Since a TDD test expresses desired behavior, it initially fails. Then the engineer writes just enough software to allow the test to pass; that is, the engineer implements the desired behavior. After the latest test passes, the engineer should refactor the software by cleaning up …",6
Dazed droids: A longitudinal study of android inter-app vulnerabilities,"Ryan Johnson, Mohamed Elsabagh, Angelos Stavrou, Jeff Offutt",2018/5/29,Book Proceedings of the 2018 on Asia Conference on Computer and Communications Security,"Android devices are an integral part of modern life from phone to media boxes to smart home appliances and cameras. With 38.9% of market share, Android is now the most used operating system not just in terms of mobile devices but considering all OSes. As applications' complexity and features increased, Android relied more heavily on code and data sharing among apps for faster response times and richer user experience. To achieve that, Android apps reuse functionality and data by means of inter-app message passing where each app defines the messages it expects to receive. In this paper, we analyze the proliferation of exploitable inter-app communication vulnerabilities using a rich corpus of 1) a representative sample of 32 Android devices, 2) 59 official Google Android versions, and 3) the top 18,583 apps from 2016 to 2017. This corpus covers  Android builds from version 4.4 to present. To the best of our …",6
You should (and absolutely can) keep diversity in sharp focus during the enrollment surge,"Lisa C Kaczmarczyk, Alvaro Monge, Jeff Offutt, Healther Pon-Barry, Suzanne Westbrook",2015/8/13,"Conference 2015 Research in Equity and Sustained Participation in Engineering, Computing, and Technology (RESPECT)","Call it a surge, call it a bubble, just don't call it business as usual. It is no secret that enrollments in college and university computer science (CS) classes are growing rapidly and faculty are under pressure to teach more classes and significantly larger classes. They need new and creative ways to accommodate as many students as possible while maintaining excellent pedagogy. Not only that, we don't want to repeat history and worsen already poor diversity statistics with enrollment management strategies that shut out or discourage women and other under-represented groups.",6
Transformation rules for platform independent testing: An empirical study,"Anders Eriksson, Birgitta Lindström, Jeff Offutt",2013/3/18,"Conference 2013 IEEE Sixth International Conference on Software Testing, Verification and Validation","Most Model-Driven Development projects focus on model-level functional testing. However, our recent study found an average of 67% additional logic-based test requirements from the code compared to the design model. The fact that full coverage at the design model level does not guarantee full coverage at the code level indicates that there are semantic behaviors in the model that model-based tests might miss, e.g., conditional behaviors that are not explicitly expressed as predicates and therefore not tested by logic-based coverage criteria. Avionics standards require that the structure of safety critical software is covered according to logic-based coverage criteria, including MCDC for the highest safety level. However, the standards also require that each test must be derived from the requirements. This combination makes designing tests hard, time consuming and expensive to design. This paper defines a new …",6
Revision of the SE 2004 curriculum model,"Gregory W Hislop, Mark Ardis, David Budgen, Mark J Sebern, Jeff Offutt, Willem Visser",2013/3/6,Book Proceeding of the 44th ACM technical symposium on Computer science education,"Software Engineering 2004: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering (SE 2004) [1] is one volume in a set of computing curricula adopted and supported by the ACM and the IEEE Computer Society. In order to keep the software engineering guidelines up to date the two professional societies began a review and revision project in early 2011. This special session will present the results of the review, present a first draft of the revision, and provide time for discussion and input from the computing education community.",6
A test automation language for behavioral models,"Nan Li, Jeff Offutt",2013,"Publisher Technical Report, GMU-CS-TR-2013-7","Model-based testers design tests in terms of models, such as paths in graphs. Abstract tests cannot be run directly because they use names and events that exist in the model, but not the implementation. Testers usually solve this mapping problem by hand. Model elements often appear in many abstract tests, so testers write the same redundant code many times. This is time-consuming, labor-intensive, and error-prone. This paper presents a language to automate the creation of mappings from abstract tests to concrete tests. Three issues are addressed:(1) creating mappings and generating test values,(2) transforming graphs and using coverage criteria to generate test paths, and (3) solving constraints and generating concrete test.",6
What is the purpose of publishing?,Jeff Offutt,2011/12,"Source Software Testing, Verification and Reliability","Gallardo, and Merino, shows how to automatically extract PROMELA models from C programs and shows results from model checking real-time avionics software. The second, Improved code defect detection with fault links, by Hayes, Chemannoor, and Holbrook, presents results from an experimental study of fault links, or relationships between types of code faults, and the types of components where the faults are located.",6
The effectiveness of category-partition testing of object-oriented software,Alisa L Irvine,1994,Institution George Mason University,,6
Using formal methods to mechanize category-partition testing,"Paul Ammann, Jeff Offutt",1993/9,Book Technical Report ISSE-TR-93-105,,6
Integration testing of object-oriented components using FSMS: Theory and experimental details,"Leonard Gallagher, AJ Offutt","Technical report ISE-TR-04-04, Department of Information and Software Engineering, George Mason University, Fairfax, VA, July 2004. http://www. ise. gmu. edu/techrep",Total citations Cited by 6200520062007200820092010201120122013201420152016201720182019202020212022111111,,6
Plagiarism is for losers,Jeff Offutt,2015/1,"Source Software Testing, Verification and Reliability","This editorial explores different forms of plagiarism, discusses why people plagiarize, and offers strategies for avoiding unintentional plagiarism. The amount of plagiarism detected by STVR’s editorial board has increased significantly in recent years. This increase might be due to multiple factors. Like most journals, STVR now uses an automated plagiarism detector that searches tens of thousands of papers for similarities. The increase might also be partly due to the general globalization of SWE research [1]. Still, another factor is that STVR receives more submissions than in the past. Regardless of why, we now desk-reject almost a dozen submissions to STVR every year. This editorial discusses plagiarism to help potential authors understand what plagiarism is and how to avoid it.",5
The globalization of software engineering,Jeff Offutt,2013/5,"Source Software Testing, Verification and Reliability","Cotroneo, Orlando, Pietrantuono and Russo, presents a practical exploration of the issue of aging software. Software is modeled as ‘aging’by considering such things as the long-term depletion of resources from the operating system, incremental corruption of data and accumulation of numerical errors. This paper analyses the JVM’s aging characteristics.(Recommended by Michael Lyu.)",5
Model transformation impact on test artifacts: An empirical study,"Anders Eriksson, Birgitta Lindström, Sten F Andler, Jeff Offutt",2012/10/1,"Book Proceedings of the Workshop on Model-Driven Engineering, Verification and Validation","Development environments that support Model-Driven Development often focus on model-level functional testing, enabling verification of design models against their specifications. However, developers of safety-critical software systems are also required to show that tests cover the structure of the implementation. Unfortunately, the implementation structure can diverge from the model depending on choices such as the model compiler or target language. Therefore, structural coverage at the model level may not guarantee coverage of the implementation.",5
Testability of dynamic real-time systems: An empirical study of constrained execution environment implications,"Birgitta Lindström, Jeff Offutt, Sten F Andler",2008/4/9,"Conference 2008 1st International Conference on Software Testing, Verification, and Validation","Real-time systems must respond to events in a timely fashion; in hard real-time systems the penalty for a missed deadline is high. It is therefore necessary to design hard real-time systems so that the timing behavior of the tasks can be predicted. Static real-time systems have prior knowledge of the worst-case arrival patterns and resource usage. Therefore, a schedule can be calculated off-line andtasks can be guaranteed to have sufficient resources to complete (resource adequacy). Dynamic real-time systems, on the other hand, do not have such prior knowledge, and therefore must react to events when they occur. They also must adapt to changes in the urgencies of various tasks, and fairly allocate resources among the tasks. A disadvantage of static real-time systems is that a requirement on resource adequacy makes them expensive and often impractical. Dynamic real-time systems, on the other hand, have the …",5
"Programmers Ain’t Mathematicians, and Neither Are Testers",Jeff Offutt,2008,"Conference Formal Methods and Software Engineering: 10th International Conference on Formal Engineering Methods, ICFEM 2008, Kitakyushu-City, Japan, October 27-31, 2008. Proceedings 10","Formal methods have been developed for decades. An early promise was that we could use formal methods to ”prove” our programs correct.We have also tried to use formal methods to completely specify functional behavior of programs and to partially specify specific aspects of software behavior. Research into formal methods have led to weaker techniques to ”model” functional behavior, less completely and less precisely, but in ways that are easier to use. Despite these years of activity, formal methods are still seldom used in industry. As software engineering researchers, we are compelled to take the view that there must be a path from our research to actual use in industry, where real software developers use our ideas to help create real, and better, software. Thus we must ask, are formal methods a solution in search of a problem?",5
Class-component testability analysis,"Supaporn Kansomkeat, Jeff Offutt, Wanchai Rivepiboon",2006/2/15,"Journal Proceedings of the 5th WSEAS International Conference on Software Engineering, Parallel and Distributed Systems","Testability is a quality factor used to predict the amount of effort required for software testing and to indicate the difficulty of revealing faults. This paper presents a quantitative testability analysis method for a software component that can be used when the source program is not available, but the bytecode is (as in Java. class files). This process analyzes the testability of each location to evaluate the component testability. The testability of a location is analyzed by computing the probability that the location will be executed and, if the location contains a fault, the execution will cause the fault to be revealed as a failure. This analysis process helps developers measure component testability and determine whether the component testability should be increased before the component is reused. In addition, low testability locations are identified.",5
A comparative evaluation of tests generated from different UML diagrams: diagrams and data,"Aynur Abdurazik, Jeff Offutt, Andrea Baldini",2005/4,Book Tech. Rep. ISE-TR-05-04,"This paper presents a single project experiment on the fault revealing capabilities of model-based test sets. The tests are generated from UML statecharts and UML sequence diagrams. This experiment found that the statechart test sets did better at revealing unit level faults than the sequence diagram test sets, and the sequence diagram test sets did better at revealing integration level faults than the statechart test sets. The statecharts also resulted in more test cases than the sequence diagrams. The experiment showed that model-based testing can be used to systematically generate test data and indicates that different UML models can play different roles in testing. This technical report version includes appendices with data that does not fit in a published paper.",5
SEEWeb: making experimental artifacts available,"Jeff Offutt, Yuan Yang, Jane Huffman Hayes",2004/9/1,Journal ACM SIGSOFT Software Engineering Notes,"This position paper suggests that some of the technical and methodological challenges facing software testing researchers can be addressed by establishing a repository of experimental software artifacts, in particular, artifacts that are related to software testing empirical research. We introduce the Software Engineering Experiments on the Web (SEEWEB) project, a Web site that is created to be a convenient and usable infrastructure for gathering, organizing, and distributing experimental software artifacts. A common problem in designing software engineering and software testing experiments is finding experimental artifacts that are appropriate for the experiment, convenient to gather and use, and will fit with other experimental artifacts. SEEWEB was initially funded by the NSF and is offered as a service to the community and provides access to experimental artifacts through an interface that allows browsing …",5
Efficiently finding data flow subsumptions,"Marcos Lordello Chaim, Kesina Baral, Jeff Offutt, Mario Concilio, Roberto PA Araujo",2021/4/12,"Conference 2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST)","Data flow testing creates test requirements as definition-use (DU) associations, where a definition is a program location that assigns a value to a variable and a use is a location where that value is accessed. Data flow testing is expensive, largely because of the number of test requirements. Luckily, many DU-associations are redundant in the sense that if one test requirement (e.g., node, edge, DU-association) is covered, other DU-associations are guaranteed to also be covered. This relationship is called subsumption. Thus, testers can save resources by only covering DU-associations that are not subsumed by other testing requirements. Although this has the potential to significantly decrease the cost of data flow testing, finding subsumption among DU-associations is quite difficult. Previous solutions are costly and contain subtle flaws that sometimes lead to incorrect results. We model the data flow testing …",4
Designing a model of computer science professional development for elementary educators in inclusive settings,"Amy Hutchison, Jamie Colwell, Kristie Gutierrez, Anya Evmenova, Jeff Offutt, Valerie Taylor",2021/4,Journal Journal of Technology and Teacher Education,"New computer science standards are being rapidly introduced at the elementary level but little is known about how to prepare teachers to learn and teach the content of these standards, or how to support students with disabilities in learning computer science. Accordingly, we designed and studied the Inclusive Computer Science Model of Professional Development to prepare teachers to integrate computer science for students with disabilities. This paper presents results from this design-based study to understand the factors that inhibited and enhanced teachers’ participation in the professional development and how participation in the professional development influenced teachers’ instruction and perceptions about teaching computer science to students with disabilities. Results revealed two inhibiting factors and one enhancing factor for participation. Further, although teachers did increase their integration of …",4
Using Petri nets to test concurrent behavior of web applications,"Sunitha Thummala, Jeff Offutt",2016/4/11,"Conference 2016 IEEE Ninth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Web applications are used by companies across the world to deploy their products and services. Because of the technologies used to build web applications, they are by nature concurrent, for example, multiple users can have problems when accessing the same limited resources. The combination of the stateless nature of web applications and concurrent behavior creates unique challenges. Models have traditionally been used to test specific aspects of systems. However, existing web application models do not effectively address the combination of concurrent behavior and stateless protocol. This research project is using a novel Petri net-based model for web applications. This paper defines a novel way to design model-based coverage criteria tests that address concurrent behavior involving HTTP browser-based sessions. A tool that extracts the Petri net model of a web application has been developed and used …",4
Globalization—standards for research quality,Jeff Offutt,2014/3,"Source Software Testing, Verification and Reliability","This issue features three interesting papers, all of which offer real solutions to real problems, and demonstrate their success on industrial software. The first,‘A practical model-based statistical approach for generating functional test cases: application in the automotive industry’, by Awedikian and Yannou, presents a new way to generate tests from models. The results include a tool that selects test inputs (the test generation problem), predicts the expected results (the oracle problem), and suggests when testing can stop (the stopping problem). They have demonstrated their approach on automotive software.(Recommended by Hong Zhu.) The second,‘A novel approach to software quality risk management’, by Bubevski, offers an advance in managing the risk of software. Bubevski’s technique uses Six Sigma and Monte Carlo simulation and has been successfully used on industrial software.(Recommended by Min …",4
globalization—language and dialects,Jeff Offutt,2013/6,"Source Software Testing, Verification and Reliability","This issue has two excellent papers. The first, Testing and verification in service-oriented architecture: A survey, by Bozkurt, Harman and Hassoun, is another detailed survey from the Centre for Research in Evolution, Search and Testing at University College London. The authors do a wonderful job summarizing testing research on service-oriented architecture, covering no less than",4
Using an existing suite of test objects: Experience from a testing experiment,"Birgitta Lindström, Mats Grindal, Jeff Offutt",2004/9/1,Journal ACM SIGSOFT Software Engineering Notes,"This workshop paper presents lessons learned from a recent experiment to compare several test strategies. The test strategies were compared in terms of the number of tests needed to satisfy them and in terms of faults found. The experimental design and conduct are discussed, and frank assessments of the decisions that were made are provided. The paper closes with a summary of the lessons that were learned.",4
"Maintainability of the linux kernel. Retrieved 14 Dec, 2003","SR Schach, B Jin, DR Wright, GZ Heller, AJ Offutt",2003,Total citations Cited by 42005200620072008211,,4
Applying a semantic fault model to the empirical study of corrective maintenance,"Jane Huffman Hayes, Jeff Offutt",2002/10,"Journal Eighth IEEE Workshop on Empirical Studies of Software Maintenance, Montreal, Canada","A full understanding of the characteristics of faults is crucial to several important research areas in testing and software maintenance. Applicable maintenance research areas include change impact analysis, maintainability, regression testing, and comparative evaluation of maintenance techniques. We explore the fundamental nature of faults by looking at the differences between a syntactic and semantic characterization of faults. We offer definitions of these characteristics and explore the differentiation. We discuss the concept of “size” of program faults. This model is then directly applied to changes in corrective maintenance. The measurement of fault size provides interesting and useful distinctions between the syntactic and semantic characterization of changes.",4
"Input validation testing: A requirements-driven, system level, early lifecycle technique","Jane Huffman Hayes, Jeff Offutt",1998/10,Journal Proceedings of the 11th International Conference on Software Engineering and its Applications,"This paper addresses the problem of statically analyzing input command syntax as defined in interface and requirements specifications and then generating test cases for input validation testing. The IVT (Input Validation Testing) technique has been developed, a proof-of-concept tool (MICASA) has been implemented, and validation has been performed. Empirical validation on actual industrial software (for the Tomahawk Cruise Missile) shows that as compared with senior, experienced testers, MICASA found more requirement specification defects, generated test cases with higher syntactic coverage, and found additional defects. Additionally, the tool performed at significantly less cost.",4
Version 3.0. Albert’s User Guide,"DP Jacobs, D Lee, SV Muddana, AJ Offutt, K Prabhu, T Whiteley",1996,Publisher Clemson University,"Albert is an interactive research tool to assist the specialist in the study of nonassociative algebra. This document serves as a technical guide to Albert. We refer the reader to [1] for a more casual tutorial. The main problem addressed by Albert is the recognition of polynomial identities. Roughly, Albert works in the following way. Suppose a user wishes to study alternative algebras. These are algebras dened by the two polynomial identities (yx) xy (xx) and (xx) yx (xy), known respectively as the right and left alternative laws. In particular, the user wishes to know if, in the presence of the right and left alternative laws,(a; b; c)[a; b] is also an identity. Here (a; b; c) denotes (ab) ca (bc),[a; b] denotes ab ba, and xy denotes xy+ yx. The user rst supplies Albert with the right and left alternative laws, using the identity command. Next, the user supplies the problem type. This refers to the number and degree of letters in the target …",4
Using mutation analysis to test software,AJ Offutt,1990,Journal Proceedings of the Seventh International Conference on Testing Computer Software,,4
Practice makes better: quiz retake software to increase student learning,"Kesina Baral, Jeff Offutt, Paul Ammann, Rasika Mohod",2021/8/23,Book Proceedings of the 3rd International Workshop on Education through Advanced Software Engineering and Artificial Intelligence,"In the past few years, we have made several pedagogical changes to the way we teach and assess student knowledge in our courses.These courses are undergraduate software engineering courses taken in the third or fourth years, and graduate (non-research) courses taken as part of a master’s degree. They are taken by software engineering majors and computer science majors. This paper focuses on a specific technique–allowing students to retake weekly quizzes.We use weekly quizzes to offer more frequent, yet lower stakes,assessments than the traditional midterm exam. Quizzes are usually given at the beginning of class meetings. We offer students who under-performed or who missed a quiz the chance to try again. A major contribution of this paper is a description of scheduling soft-ware we developed to facilitate the retake process. Retake quizzes are different from the original quizzes, but cover the …",3
SiMut: exploring program similarity to support the cost reduction of mutation testing,"Alessandro V Pizzoleto, Fabiano C Ferrari, Lucas D Dallilo, Jeff Offutt",2020/10/24,"Conference 2020 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Scientists have created many cost reduction techniques for mutation testing, and most of them reduce cost with minor losses of effectiveness. However, many of these techniques are difficult to generalize, difficult to scale, or both. Published results are usually limited to a modest collection of programs. Therefore, an open question is whether the results of a given cost reduction technique on programs studied in the paper will hold true for other programs. This paper introduces a conceptual framework, named SiMut, to support the cost reduction of mutation testing based on historical data and program similarity. Given a new, untested program u, the central idea is applying to u the same cost reduction strategy applied to a group G of programs that are similar to u and have already been tested with mutation, and check for consistency of results in terms of reduced costs and quality of test sets. SiMut includes activities to …",3
Experimental evaluation of redundancy in android mutation testing,"Lin Deng, Jeff Offutt",2018/12,Journal International Journal of Software Engineering and Knowledge Engineering,"Because of the widespread usage of Android devices, the Android ecosystem has the highest numbers of users, developers, and app downloads. Researchers find that many Android apps are not sufficiently tested, which may lead to crashes, incorrect behaviors, and security vulnerabilities. Mutation testing is a syntax-based software testing technique that is very effective at designing high-quality tests and evaluating pre-existing tests. Our prior research designed and implemented Android mutation testing technique, and then used experiments to assess its strength. However, the high computational cost of Android mutation testing possibly limits its industrial application. This paper presents an experimental evaluation that investigates redundant mutation operators in Android mutation analysis. While maintaining the test quality, our goal is to reduce the cost by excluding redundant mutation operators or improving …",3
What is the value of the peer‐reviewing system?,Jeff Offutt,2018/8,"Source Software Testing, Verification and Reliability","Scientists have been publishing research papers in scholarly journals since the 17th century [1]. And the peer review system, flawed as it is, has been used the entire time. I've written about peer reviewing before, including how to do it [2], why should we do it [3], how not to do it [4], and the benefits to reviewers [5]. Here I ask an existential question: What is the value of peer reviewing? As a journal editor, I see many papers that our readers never do. Papers that are plagiarised, papers that have no scientific content, papers that have very little scientific content, and papers that are written so badly they are incomprehensible. We desk‐reject almost half of STVR's submissions. We even have template emails for the different cases.",3
Automatically Repairing SQL Faults,"Yun Guo, Nan Li, Jeff Offutt, Amihai Motro",2018/7/16,"Conference 2018 IEEE International Conference on Software Quality, Reliability and Security (QRS)","SQL is the standard database language, yet SQL statements can be complex and expensive to debug by hand. Automatic program repair techniques have the potential to reduce cost significantly. A previous attempt to repair SQL faults automatically used a decision tree (DT) algorithm that succeeded in some cases, but also generated many patches that passed the automated tests but that were not acceptable to the engineers. This paper proposes a novel fault localization and repair technique to repair faulty SQL statements. It targets faults in two common SQL constructs, JOIN and WHERE. It identifies the fault location and type precisely, and then creates a patch to fix the fault. We implemented this technique in a tool, and evaluated it on five medium to large-scale databases using 825 faulty queries with various complexity and faulty types. Experimental results showed that this technique can identify and repair JOIN …",3
Reducing the Cost of Android Mutation Testing.,"Lin Deng, Jeff Offutt",2018,Conference SEKE,"Due to the high market share of Android mobile devices, Android apps dominate the global market in terms of users, developers, and app releases. However, the quality of Android apps is a significant problem. Previously, we developed a mutation analysis-based approach to testing Android apps and showed it to be very effective. However, the computational cost of Android mutation testing is very high, possibly limiting its practical use. This paper presents a cost-reduction approach based on identifying redundancy among mutation operators used in Android mutation analysis. Excluding them can reduce cost without affecting the test quality. We consider a mutation operator to be redundant if tests designed to kill other types of mutants can also kill all or most of the mutants of this operator. We conducted an empirical study with selected open source Android apps. The results of our study show that three operators are redundant and can be excluded from Android mutation analysis. We also suggest updating one operator’s implementation to stop generating trivial mutants. Additionally, we identity subsumption relationships among operators so that the operators subsumed by others can be skipped in Android mutation analysis.",3
How to revise a research paper,Jeff Offutt,2016/3,"Source Software Testing, Verification and Reliability","Ruiz and Pérez, presents a way to integrate verification into a GUI during execution. The runtime verifier reads verification rules from files created by the engineers and checks the state of the GUI for violations while running (recommended by Peter Mueller). The second, Model-Based",3
Who Is An Author?,Jeff Offutt,2015/3,"Source Software Testing, Verification and Reliability","Techniques and benefits, by Farjo, Assi, and Masri, presents results of analysis of execution profiles. They invented six ways to reduce the size of execution profiles and empirically measured the effect on the quality of analysis after reducing the profiles.(Recommended by TY Chen.) The third paper, Automated metamorphic testing of variability analysis tools, by Segura, Durán, Sánchez, Le Berre, Lonca, and Ruiz-Cortés, invent a technique for solving the oracle problem when testing tools that analyze the variability of software.(Recommended by TH Tse.) Combined, these three papers have a whopping 14 co-authors, which leads in perfectly to the subject of this editorial: determining authorship.",3
Globalization—references and citations,Jeff Offutt,2014/1,"Source Software Testing, Verification and Reliability","This issue has three exciting papers that show how test tools can help in areas ranging from modelbased testing to embedded software to Web application software. The first, Tool Support for the Test Template Framework, by Cristiá, Albertengo, Frydman, Plüss, and Rodríguez Monetti, describes a new tool to support model-based testing with Z specifications. Their tool, Fastest, is open-source and available online.(Recommended by Paul Strooper.) The second, Model Checking Trampoline OS: A Case Study on Safety Analysis for Automotive Software, by Choi, presents a study of the use of model checking to check safety properties in automotive operating systems. The author was able to find evidence of safety problems in the Trampoline operating system.(Recommended by",3
A model IT curriculum for the UAE University,"PJC Denning, Ravi Athale, Nada Dabbagh, Daniel Menascé, Jeff Offutt, Mark Pullen, Steve Ruth, Ravi Sandhu",2010,"Description ObjectiveThe University of the United Arab Emirates (UAEU) is establishing a college of information technology, which they intend to be among the best in the world. To accomplish this, they have requested assistance in designing a forward-looking, innovative curriculum, and approaches to engaging with IT research and with professional and entrepreneurial practice.The IT curriculum task force is charged to produce an innovative model curriculum to serve as a model for the new IT college and to recommend ways of integrating curriculum with research and with professional practice. The curriculum model should incorporate innovations and best practices but need not be constrained by traditions that no longer make sense. The curricula of degree programs for which there is a duly constituted accreditation body should be accreditable. The College will set up external advisory panels to assist in the ongoing review of the other degree programs.",Objective,3
Mutation Testing Tool for Java,"Munawar Hafiz, YS Ma, J Offutt",2008,Description Mutation testing takes a different approach to testing by asking questions about the efficacy of test cases. The test cases are tested by introducing bugs in the code. The test cases are then run on the original program and all the mutants. The effectiveness of a test case is determined by the percentage of mutants it kills. This report describes a mutation tool for Java programs.,Mutation testing takes a different approach to testing by asking questions about the efficacy of test cases. The test cases are tested by introducing bugs in the code. The test cases are then run on the original program and all the mutants. The effectiveness of a test case is determined by the percentage of mutants it kills. This report describes a mutation tool for Java programs.,3
Testing polymorphic relationships,"Roger T Alexander, Jeff Offutt",2003/9/15,Volume 15,"As we move from developing procedure-oriented to object-oriented programs, the complexity traditionally found in functions and procedures is moving to the connections among components. Different faults occur when components are integrated to form higher level structures that aggregate the behavior and state of the components. Consequently, we need to place more effort on testing the connections among components. Although object-oriented technologies provide abstraction mechanisms for building components that can then be integrated to form applications, it also adds new compositional relations that can contain faults, which are most properly found during integration testing. This paper describes techniques for analyzing and testing the polymorphic relationships that occur in object-oriented software. The techniques adapt traditional data flow coverage criteria to consider definitions and uses among state variables of classes, particularly in the presence of inheritance and polymorphic overriding of state variables and methods. The application of these techniques can result in an increased ability to find faults and to create overall higher quality software.",3
Generating Test Data from State-Based Specifications. Software Testing,"J Oﬀutt, S Liu, A Abdurazik, P Ammann",2003,Journal Verification and Reliability,,3
Designing an IT college,"Peter J Denning, Ravi Athale, Nada Dabbagh, Daniel Menascé, Jeff Offutt, Mark Pullen, Steve Ruth, Ravi Sandhu",2002,Journal Networking the Learner: Computers in Education,"The University of the United Arab Emirates (UAEU) commissioned an international panel of experts to devise a model curriculum for their new College of Information Technology. The model has a university core in the freshman year, an IT core in the second year, and a professional concentration in one of seven degree programs in the third and fourth year. The seven degrees are computer science, computer systems engineering, software engineering, information systems, network engineering, information security, e-commerce, and educational technology. The curriculum is structured around a progressive-competence model, whose graduates meet recognised standards for entry-level professionals.",3
TUMS: testing using mutant schemata,"Roland H Untch, Mary Jean Harrold, A Jefferson Offutt",1997/4/2,Book Proceedings of the 35th Annual Southeast Regional Conference,"Mutation analysis is a way of quantifying the quality of a test set used in unit testing software. Unfortunately, mutation analysis performed using the conventional interpretive method is very slow. A new non-interpretive method, the MSG method, that has the promise of much higher performance was recently advanced. In this paper we describe TUMS, a prototype MSG-based implementation of a mutation analysis system. We also describe several experiments using this prototype that compare the performance of mutation analysis using the MSG method with mutation analysis using the conventional method. Our experiments strongly suggest that using the new MSG method is significantly faster than using the conventional method, with speed-ups as high as an order-of-magnitude observed.",3
A five year perspective on software engineering graduate programs at george mason university,"Paul Ammann, Hassan Gomaa, Jeff Offutt, David Rine, Bo Sanden",1994,"Conference Software Engineering Education: 7th SEI CSEE Conference San Antonio, Texas, USA, January 5–7, 1994 Proceedings 7","This paper describes the experience obtained at George Mason University while developing a Master of Science program in software engineering. To date, the program has graduated over 45 students, with a current production rate of 10 to 15 a year. The paper also describes experience with a certificate program in software engineering, which is a software engineering specialization taken by Masters students in related disciplines, and the software engineering specialization within the PhD program in Information Technology. We discuss our courses, students, the successes that we have had, and the problems that we have faced.",3
What is a facade journal?,Jeff Offutt,2018/9,"Source Software Testing, Verification and Reliability",Scientific journals have helped scientists advance research for centuries. The peer‐review system [1] lets journals filter for papers that advance our scientific knowledge and also helps authors improve their papers. This system has contributed to unbelievable scientific progress and incredible progress in human civilization.,2
Identifying useful mutants to test time properties,"Birgitta Lindström, Jeff Offutt, Loreto Gonzalez-Hernandez, Sten F Andler",2018/4/9,"Conference 2018 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)","Real-time systems have to be verified and tested for timely behavior as well as functional behavior. Thus, time is an extra dimension that adds to the complexity of software testing. A timed automata model with a model-checker can be used to generate timed test traces. To properly test the timely behavior, the set of test traces should challenge the different time constraints in the model. This paper describes and adapts mutation operators that target such time constraints in timed automata models. Time mutation operators apply a delta to the time constraints to help testers design tests that exceed the time constraints. We suggest that the size of this delta determines how easy the mutant is to kill and that the optimal delta varies by the program, mutation operator, and the individual mutant. To avoid trivial and equivalent time mutants, the delta should be set individually for each mutant. We discuss mutant subsumption …",2
Self‐plagiarism is not a thing,Jeff Offutt,2018/3,"Source Software Testing, Verification and Reliability","I've been ranting on ethics and plagiarism for awhile, both here and elsewhere [1, 2]. I have been plagiarised [3, 4], I have been accused of plagiarising (although I did not!), and I deal with plagiarism cases regularly as reviewer and editor. I've also been asked to speak about ethics in publishing to PhD students and young faculty at my university. This is a short rant in the other direction—there is no such thing as self plagiarism! I recently joined a Facebook discussion on this topic when one of my colleagues complained about a reviewer who wanted to reject a paper because it contained “self plagiarism.” Since I was originally educated as a mathematician, I did what all mathematicians do first: started with definitions. Below are three definitions for plagiarism (all properly quoted and with sources given, by the way):",2
How to get your paper rejected from STVR,Jeff Offutt,2014/9,"Source Software Testing, Verification and Reliability","This editorial is based on a talk I gave at the ICST PhD symposium in April 2014. I had fun giving the talk and hope you enjoy reading this summary. First, I want to make it clear that I am highly qualified to give advice on getting papers rejected. I have well over 100 rejections in my time and may well be the most rejected software testing researcher of all time.",2
Globalization–ethics and plagiarism,Jeff Offutt,2014/5,"Source Software Testing, Verification and Reliability","Compilation with Preservation of Structural Code Coverage Metrics to Support Software Testing, by Kirner and Hass, presents results on mapping coverage computed at the source level to coverage at the executable level. Their suggestion is to modify compilers to add additional information to the executable version of the software to make it possible to back-calculate coverage measured on the executable source.(Recommended by Jose Maldonado.) The second, A Hitchhiker’s Guide to Statistical Tests for Assessing Randomized Algorithms in Software Engineering, by Arcuri and Briand, presents guidelines on using statistical tests in experiments involving randomized algorithms. The authors make the point that randomized algorithms have different characteristics than other kinds of experimental research, which means different statistical analysis techniques are needed. The paper analyzes several recent …",2
An Evaluation of the Minimal-MUMCUT Logic Criterion and Prime Path Coverage.,"Garrett Kent Kaminski, Upsorn Praphamontripong, Paul Ammann, Jeff Offutt",2010,Conference Software Engineering Research and Practice,"This paper presents comparisons of the Minimal-MUMCUT logic criterion and prime path coverage. A theoretical comparison of the two criteria is performed in terms of (1) how well tests satisfying one criterion satisfy the other and (2) fault detection. We then compare the criteria experimentally. For 22 programs, we develop tests to satisfy Minimal-MUMCUT and prime path coverage. We use these tests in two separate experiments. First we measure the effectiveness of the tests developed for one criterion in terms of the other. Next we investigate the ability of the test sets to find actual faults. Faults are seeded via a mutation tool and then supplemented with mutants created by DNF logic mutation operators. We then measure the number of non-equivalent mutants killed by each test set. Results indicate that while prime path-adequate test sets are closer to satisfying Minimal-MUMCUT than vice versa, the criteria had similar fault detection and Minimal-MUMCUT required fewer tests.",2
Standards for reviewing papers,Jeff Offutt,2007/9,"Source Software Testing, Verification and Reliability","When I started submitting papers, I observed that reviewers were sometimes very unscientific in their evaluations. They assumed that authors intentionally wrote stupid things instead of simply making mistakes, assumed that something they didn’t understand must be wrong, would criticize any paper that omitted references to their own work, and expected theoretical papers to be empirical and empirical papers to be theoretical.",2
Six issues in testing event-triggered real-time systems,"Birgitta Lindström, Robert Nilsson, AnnMarie Ericsson, Mats Grindal, Sten F Andler, Bengt Eftring, Jeff Offutt",2007,Publisher Institutionen för kommunikation och information,"Verification of real-time systems is a complex task, with problems coming from issues like concurrency. A previous paper suggested dealing with these problems by using a time-triggered design, which gives good support both for testing and formal analysis. However, a time-triggered solution is not always feasible and an event-triggered design is needed. Event-triggered systems are far more difficult to test than time-triggered systems.",2
Using Combination Strategies for Software Testing in Practice-A proof-of-concept,"M Grindal, AG Dahlstedt, AJ Offutt, J Mellin",2006,"Publisher Technical Report HS-IKI-TR-06-010, School of Humanities and Informatics, University of Skövde","In this thesis, the overall conclusion is that combination strategies,(ie, test case selection methods that manage the combinatorial explosion of possible things to test), can improve the software testing in most organizations. The research underlying this thesis emphasizes relevance by working in close relationship with industry.",2
Test case generation for testing of timeliness: Extended version,"Robert Nilsson, Jeff Offutt, Jonas Mellin",2005,Publisher Institutionen för kommunikation och information,"Temporal correctness is crucial for real-time systems. There are few methods to test temporal correctness and most methods used in practice are ad-hoc. A problem with testing real-time applications is the response-time dependency on the execution order of concurrent tasks. Execution orders in turn depends on scheduling protocols, task execution times, and use of mutual exclusive resources apart from the points in time when stimuli is injected. Model-based mutation testing has previously been proposed to determine the execution orders that need to be tested to increase confidence in timeliness. An effective way to automatically generating such test cases for dynamic real-time systems is still needed. This paper presents a method using heuristic-driven simulation for generation of test cases.",2
Modeling and testing web-based applications,"AJ Offutt, Y Wu",2002/11,"Journal Relatório Técnico ISE-TR-02-08, George Mason University, Fairfax, VA, EUA. Disponıvel em: http://ise. gmu. edu/techrep/2002/02",,2
Uniting the Orthogonal. In proceedings of Mutation 2000: Mutation Testing in the Twentieth and the Twenty First Centuries,"AJ Offutt, Roland Untch",2000/10,"Journal San Jose, CA",,2
Generating Test Cases from UML Specificatiion R]· ISE—TR-99-09,"Aynur Abdurazik, Jef Ofutt",1999/5,Journal Information and Software Engineering George Mason University,,2
Integrating testing with the software development process,"Zhenyi Jin, Jeff Offutt",1995/8/10,"Publisher Technical Report ISSE-TR-95-112, George Mason University","Software testing is usually postponed to the end of the development, after coding has started, or even after it has ended. By waiting until this late in the process, testing winds up being compressed {there are not enough resources (time and budget) remaining, problems with previous stages have been solved by taking time and dollars from testing, and there is insu cient time to adequately plan for testing. In this paper, we present an integrated approach to testing software, where testing activities begin as soon as development activities begin, and are carried out in parallel with the development activities. We present speci c activities {including planning, active testing, and development in uencing activities {that are associated with each of the traditional lifecycle phases. These activities can be carried out by the developers or separate test engineers, and can be associated with development activities within the con nes of any development process. These activities allows the tester to detect and prevent throughout the software development process, leading to more reliable and higher quality software.",2
Unit Testing Versus Integration Testing,A. Jefferson  Offutt,1991/10/26,"Conference Test Conference, 1991, Proceedings., International","Industry typically leaves unit testing to the individual programmers, who are given little or no formal training or test tools. The few tools that are available are usually test support tools such as drivers or test case managers, rather than tools that solve the hard problems of generating test cases to satisfy formal criteria. In extreme cases, the testing problem is solved by a huge investment in labor. It is common, when developing mission critical software, to use as many as one tester for every programmer. Testing researchers, on the other hand, try to develop testing techniques that can be utilized to test a wide variety of software. Formal testing techniques such as statement coverage, branch coverage, mutation analysis, and data flow coverage were developed to test software units, and there is little or no reason to believe that they can be applied to complete programs.",2
IMSCU programmer's reference manual,"AJ Offutt, SD Lee",1991,"Publisher Technical report 91-121, Department of Computer Science, Clemson University, Clemson SC",,2
Mothra internal documentation,"AH Agrawal, RA DeMillo, Wm Hsu, Wy Hsu, EW Krauser, AJ Offutt, H Pan, EH Spafford",1989/7,"Publisher version 1.5. Technical report SERC-TR, Software Engineering Research Center, Purdue University, West Lafayette IN",,2
"Designing divergent thinking, creative problem solving exams","Jeff Offutt, Kesina Baral",2022/5/21,Book Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: Software Engineering Education and Training,"This experience report paper reports on case studies of final exams that used creative problem solving to assess students' ability to apply the material, and divergent thinking to ensure that each student's exam was unique. We report on two senior-level software engineering courses, taught a total of six times across three semesters. The paper gives enough information for readers to adapt this method in their own courses. Our exams include built-in divergence properties, which are elements or decisions that lead students to more than one good answer. Based on our experience, divergent thinking, creative problem solving exams not only provide excellent assessments of student knowledge, but ensure the integrity of the exam process, even when students work without supervision. We developed this strategy during the pandemic when all courses were online, but find them to be better than our traditional exams …",1
A data flow analysis framework for data flow subsumption,"Marcos Lordello Chaim, Kesina Baral, Jeff Offutt",2021/1/15,Journal arXiv preprint arXiv:2101.05962,"Data flow testing creates test requirements as definition-use (DU) associations, where a definition is a program location that assigns a value to a variable and a use is a location where that value is accessed. Data flow testing is expensive, largely because of the number of test requirements. Luckily, many DU-associations are redundant in the sense that if one test requirement (e.g., node, edge, DU-association) is covered, other DU-associations are guaranteed to also be covered. This relationship is called subsumption. Thus, testers can save resources by only covering DU-associations that are not subsumed by other testing requirements. In this work, we formally describe the Data Flow Subsumption Framework (DSF) conceived to tackle the data flow subsumption problem. We show that DFS is a distributive data flow analysis framework which allows efficient iterative algorithms to find the Meet-Over-All-Paths (MOP) solution for DSF transfer functions. The MOP solution implies that the results at a point  are valid for all paths that reach . We also present an algorithm, called Subsumption Algorithm (SA), that uses DSF transfer functions and iterative algorithms to find the local DU-associations-node subsumption; that is, the set of DU-associations that are covered whenever a node  is toured by a test. A proof of SA's correctness is presented and its complexity is analyzed.",1
How can we recognize facade journals?,Jeff Offutt,2018/11,"Source Software Testing, Verification and Reliability","This paper contains two terrific papers on testing. A hybrid approach to testing for nonfunctional faults in embedded systems using genetic algorithms, by Tingting Yu, Witawas Srisa-an, Myra B. Cohen, and Gregg Rothermel, investigates challenging aspects of testing for nonfunctional faults in embedded software.(Recommended by Gordon Fraser.) Approaches for computing test-case-aware covering arrays, by Ugur Koc and Cemal Yilmaz, presents several novel approaches to correctly compute test-case-aware covering arrays.(Recommended by Mauro Pezzè.) This editorial continues a series about what I call “facade journals.” In the 28 (5) issue, I pointed out that peer reviews are the most important mechanism research journals use to ensure scientific quality of published papers [1]. Then in the 28 (6) issue, I defined “facade journals” to be journals that publish papers that look like research but that do not truly …",1
Do we need to teach ethics to PhD students?,Jeff Offutt,2018/1,"Source Software Testing, Verification and Reliability","This issue contains two excellent papers that address modern and important problems.“Why Does the Orientation Change Mess Up My Android Application? From GUI Failures to Code Faults,” by Domenico Amalfitano, Vincenzo Riccio, Ana CR Paiva, and Anna Rita Fasolino, investigates the common problem of mobile apps that fail when we turn our devices sideways.(Recommended by Marcio Delamaro.)“CoopREP: Cooperative Record and Replay of Concurrency Bugs,” by Nuno Machado, Paolo Romano, and Luís Rodrigues, presents a system that addresses the difficult problem of replicating concurrent faults, which often appear to be random.(Recommended by Paul Strooper.) I was in a faculty meeting last week where we were discussing a new course proposal on the research process for new PhD students. One topic in the proposal was integrity and ethics.",1
Beware of predatory journals,Jeff Offutt,2017/11,"Source Software Testing, Verification and Reliability","This issue contains two papers. Debugging‐Workflow‐aware Software Reliability Growth Analysis, by Cinque, Cotroneo, Pecchia, Pietrantuono, and Russo, presents a reliability growth model that is based on data drawn from a project's bug tracking systems.(Recommended by Michael Lyu.) Prioritizing MCDC Test Cases by Spectral Analysis of Boolean Functions, by Ayav, proposes a method to prioritize the order in which we run tests by using an analysis based on logic test criteria (MCDC). This is less expensive than prioritization strategies based on mutation and does not lose significant accuracy.(Recommended by Shaoying Liu.)",1
How to extend a conference paper to a journal paper,Jeff Offutt,2016/11,"Source Software Testing, Verification and Reliability","In a previous editorial, I set out STVR’s policy on extending conference papers to journal submissions [1]. The major requirements are that the journal version must have at least 30% new material, the journal version must include a citation to the conference paper, and the journal version must discuss the conference paper and summarize the new material. Here I suggest some practical guidelines for how to do the extension.",1
STVR policy on extending conference papers to journal submissions,Jeff Offutt,2016/6,"Source Software Testing, Verification and Reliability","This issue presents three novel solutions to quite difficult problems. Stochastic modelling and simulation approaches to analysing enhanced fault tolerance on service-based software systems, by Kuan-Li Peng and Chin-Yu Huang, presents two approaches to improve the effectiveness of fault tolerant analysis.(Recommended by Min Xie.) Exhaustive test sets for algebraic specifications, by Marc Aiguier, Agnès Arnould, Pascale Le Gall, and Delphine Longuet, presents a way to generate test sets from formal specifications that are not only complete, but exhaustive.(Recommended by Lu Zhang.) Using combinatorial testing to build navigation graphs for dynamic web applications, Wenhua Wang, Sreedevi Sampath, Yu Lei, Raghu Kacker, Richard Kuhn, and James Lawrence, presents a new technique to address the very difficult problem of finding navigation structures within web applications. This is difficult because …",1
How to write an effective “Response to Reviewers” letter,Jeff Offutt,2016/5,"Source Software Testing, Verification and Reliability","Czemerinski, Victor Braberman, and Sebastian Uchitel, invents new criteria to test whether APIs are used correctly. Specifically, the criteria measure the extent to which software that uses the APIs conforms to the expected protocol such as whether the methods are called in valid orders.(Recommended by Hasan Ural.) The third paper in this issue addresses the difficult oracle problem.",1
An Evaluation of the Effectiveness of the Atomic Section Model,"Sunitha Thummala, Jeff Offutt",2014,"Conference Model-Driven Engineering Languages and Systems: 17th International Conference, MODELS 2014, Valencia, Spain, September 28–October 3, 2014. Proceedings 17","Society increasingly depends on web applications for business and pleasure. As the use of web applications continues to increase, the number of failures, some minor and some major, continues to grow. A significant problem is that we still have relatively weak abilities to test web applications. Traditional testing techniques do not adequately model or test these novel technologies. The atomic section model (ASM), models web applications to support design, analysis, and testing. This paper presents an empirical study to evaluate the effectiveness of the ASM. The model was implemented into a tool, WASP, which extracts the ASM from the implementation and supports various test criteria. We studied ten web applications, totaling 156 components and 11,829 lines of code. Using WASP, we generated 207 tests, which revealed 31 faults.Seventeen of those faults exposed internal information about the …",1
Workshop on Revisions to SE 2004,"Mark Ardis, David Budgen, Gregory W Hislop, Jeff Offutt, Mark Sebern, Willem Visser",2013/5/19,Conference 2013 26th International Conference on Software Engineering Education and Training (CSEE&T),We shall conduct a half-day workshop on needed revisions to Software Engineering 2004: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering (SE 2004). A brief overview of the current guidelines and their revision status will be presented. Workshop attendees will share their experience using the current guidelines and suggest needed changes. We will provide a summary report from the workshop to other CSEE&T attendees at a Birds Of a Feather meeting later during the conference.,1
What I have learned from usability,Jeff Offutt,2013/3,"Source Software Testing, Verification and Reliability","I have recently been working on a project about usable security. An interesting thing I have observed is the many similarities between usability and testing. To start with, they both address emergent properties; that is, they address aspects of the software that do not exist until the entire system is completed. Of course, we can (and should!) test software piecewise, but some faults are not visible until the system is entirely integrated, and we certainly cannot measure reliability until the entire system is present. Usability is even more emergent—there is really no sign of usability until we get the user interface of the system in place. Many engineers and educators view usability and testing in the same way: as being unimportant to the real work of building the backend software. Or worse, usability and testing may get in the way of the real work.",1
The h‐index beats the impact factor,Jeff Offutt,2012/1,"Source Software Testing, Verification and Reliability","This issue has two papers with results on real industrial software projects. The first, On the testing of user-configurable software systems using firewalls, by Robinson and White, presents the ‘just-intime’testing strategy for user-configurable software and includes results on commercial software.",1
OOP and discrete math,Jeff Offutt,2010/3,"Source Software Testing, Verification and Reliability","This issue has three terrific papers. The first, Verification of real-time systems design, by M. Emilia Cambronero, Valentın Valero, and Gregorio Dıaz, presents a way to verify aspects of software during design. The second, A systematic representation of path constraints for implicit path enumeration technique, by Tai Hyo Kim, Ho Jung Bang, and Sung Deok Cha, proposes to encode path constraints into ‘flow facts’ to improve the accuracy of implicit path enumeration. The third, Fault localization using a model checker, by Andreas Griesmayer, Stefan Staber, and Roderick Bloem, gives a method for using model checking information to not only identify software failures, but to help find where the corresponding faults may be located.",1
Why should I review papers?,Jeff Offutt,2007/12,"Source Software Testing, Verification and Reliability","This issue has three fascinating papers. The first paper, Software component composition: A subdomain-based testing foundation, by Hamlet, proposes a theory of composing software components that is based on testing. Instead of modeling or specifying software systems directly, this paper suggests the novel approach of deriving abstractions of components from testing and then using these abstractions to model the behavior of the entire system. The second paper, A combinatorial testing strategy for concurrent programs, by Lei, Carver, Kacker and Kung, addresses the hard problem of testing concurrent software. Instead of trying to test all possible synchronization sequences, this paper presents a method and algorithm for choosing a subset of synchronization sequences that will lead to effective fault detection. The third paper, Studying the separability relation between finite state machines, by Spitsyna, El-Fakih …",1
Service Oriented Architecture Empirical Study.,"Mohammad Abu-Matar, A Jefferson Offutt",2007/7/9,Conference SEKE,"Service Oriented Architecture (SOA) has been proposed as model for distributed software development that surpasses the traditional Distributed Object Architecture (DOA) practices in many areas. However, no empirical studies have been conducted to verify the claimed benefits. This study is a first attempt at presenting empirical evidence regarding the benefits of SOA. It is a comparison between traditional DOA and SOA. The two technologies were compared on the basis of code size and development time. The results show that, as a whole, the subject application was faster to develop using the SOA method. However, the application size was larger than that developed in the DOA method.",1
Test case generation for testing of timeliness,"Robert Nilsson, J Offutt, Jonas Mellin",2006/3,Journal Proc. of the 2 Workshop on Model Based Testing,"In complex distributed real-time systems the temporal correctness is imperative for dependability. Industrial practice has few methods for testing of temporal correctness and the methods that exist are often ad-hoc. A problem associated with testing real-time is that their timeliness depends on the execution order of tasks. This is particularly problematic for eventtriggered real-time systems where the system continuously is notified of events that influence the execution order. Further, real-time systems may behave differently depending not only on time dependencies in program logic but also on differences in execution times. This paper investigates how existing test-case generation methods take these factors into consideration and explains the opportunity to construct better methods and metrics for their evaluation. An analysis of current methods for generating test cases for testing temporal properties of real-time systems is presented. The methods are classified according to their characteristics and analyzed in relation to the requirements of an event-triggered system model. The aim of the classification is to detect similarities between different test-case generation methods so that the characteristics that have an impact on the applicability of the method when testing timeliness can be determined. We conclude that existing work only consider a subset of the factors that influence timeliness, and therefore propose research activities that take these factors into consideration during test-case generation.",1
Analysis for class-component testability.,"Supaporn Kansomkeat, Jeff Offutt, WANCHAI RIVEPIBOON",2006/2,Journal WSEAS Transactions on Computers,"Testability is a quality factor used to predict the amount of effort required for software testing and to indicate the difficulty of revealing faults. Also, it can be used to estimate the difficulty of software testing. This paper presents a quantitative testability analysis method for a software component that can be used when the source program is not available, but the bytecode is (as in Java. class files). This process analyzes the testability of each location to evaluate the component testability. The testability of a location is analyzed by computing the probability that the location will be executed and, if the location contains a fault, the execution will cause the fault to be revealed as a failure. This analysis process helps developers measure component testability and determine whether the component testability should be increased before the component is reused. In addition, low testability locations are identified. This paper uses an example to evaluate the ability of this process to indicate component testability.",1
Bytecode-based analysis for increasing class-component testability,"Supaporn Kansomkeat, Jeff Offutt, Wanchai Rivepiboon",2006,Journal ECTI Transactions on Computer and Information Technology (ECTI-CIT),"Software testing attempts to reveal software faults by executing the program on input values and comparing the outputs from the execution with expected outputs. Testing software is easier when testability is high, so increasing testability allows faults to be",1
Modeling and Testing of Dynamic Integration Aspects of Web-based Applications,"X Du, Jeff Offutt, Y Wu",2004,Journal Technical Reports,"Web software applications have become complex, sophisticated programs that are based on novel computing technologies. Although powerful, these technologies bring new challenges to developers and testers. Checking static HTML links is no longer sufficient; web applications must be evaluated as complex software products. This paper focuses on two unique aspects of web applications, an extremely loose form of coupling and dynamic integration, and the ability that users have to directly change the potential flow of execution. Taken together, these allow the potential control flow to vary with each execution, and means the possible control flows cannot be determined statically. Thus we cannot perform standard analysis techniques that are fundamental to many software engineering activities. This paper presents a way to model the new couplings and the dynamic flow of control of web applications, supplying the equivalent of a control flow graph for web applications. The model is used to propose new test criteria for web applications, and results are shown from a case study on a moderate-size application.",1
Proceedings Seventh IEEE International Conference on Engineering of Complex Computer Systems,"Sten F Andler, Michael G Hinchey, Jeff Offutt",2001/1/1,Publisher IEEE Computer Society,,1
Maintaining knowledge currency in the 21st century,"Paul Ammann, Jeff Offutt",1997/4/13,Conference Proceedings Tenth Conference on Software Engineering Education and Training,"Software engineering is a rapidly changing discipline, and will continue to be so for the foreseeable future. This pace of change brings both problems and opportunities to universities that teach software engineering. Engineers ore no longer satisfied with one or two initial university education experiences, but by necessity are becoming lifetime learners, with frequent trips back to educational providers. This recurring education is needed to update engineers' knowledge with new ideas and concepts, and to update engineers' skills. In this paper, we take the position that universities can and should respond to this situation with a new model for graduate software engineering education, which we call professional currency certificates. These courses should offer the depth of knowledge and university academic credit that traditional academic courses offer, but with the convenience and practical nature of corporate …",1
"Integrating research, reuse, and integration into Software Engineering course","Roland H Untch, A Jefferson Offutt",1992/1/1,Book Proceedings of the SEI Conference on Software Engineering Education,,1
"Evaluating the role of professional development on elementary teachers’ knowledge, comfort, and beliefs related to teaching computer science to students with high-incidence …","Amy Hutchison, Kristie Gutierrez, Jamie Colwell, Anya Evmenova, Jeff Offutt, Margaret Gross",2022/6/13,Journal Journal of Research on Technology in Education,"This article reports results from the implementation of a model of professional development (PD) to help K-5 teachers develop the knowledge and skills to teach Computer Science (CS) in classrooms of diverse students, including students with high-incidence disabilities. This article describes our Inclusive CS model of PD, how we made the PD model available to teachers during a pandemic and presents quantitative and qualitative results about the impact of the PD on teachers’ knowledge, comfort, and beliefs related to teaching computer science to students. Results indicate that the teachers’ knowledge, comfort, beliefs and perceptions about teaching CS to students with disabilities significantly improved. Teachers’ knowledge and understanding of Universal Design for Learning for supporting students in learning about CS also improved.",
Graph Representation for Data Flow Coverage,"Mario Concilio Neto, Roberto PA Araujo, Marcos Lordello Chaim, Jeff Offutt",2021/7/12,"Conference 2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC)","Data flow testing helps testers design effective tests by requiring the tests to execute sequences of statements from definitions of variables to one or more subsequent uses. These def-use associations are derived from graphs that model software behavior. A ""flow graph"" that only includes paths that cover defuse associations, and not other control flows, has been defined elsewhere. Although these flow graphs have several advantages over previous graphs, as computed, they omit some valid paths, which are needed to use the graphs to discover subsumption relationships and generate test data. These omissions lead to errors in the results. This paper extends previous solutions by presenting a graph that represents all paths that cover def-use associations. The paper presents empirical data showing that this graph can be generated at reasonable cost and efficiently applied for data flow subsumption discovery.",
Self determination: A comprehensive strategy for making automated tests more effective and efficient,"Kesina Baral, Jeff Offutt, Fiza Mulla",2021/4/12,"Conference 2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST)","A significant change in software development over the last decade has been the growth of test automation. Most software organizations automate as many tests as possible, which not only saves time and money, but also increases reproducibility and reduces errors during testing. However, as software evolves over time, so must the test suites. For each software change, each test falls into one of four categories: (1) it needs to rerun as is, (2) it does not need to rerun, (3) it needs to change and rerun, (4) it should be deleted. This test management is currently done by hand, leading to shortcuts such as always running all tests (wasteful and expensive), deleting valuable tests that should be fixed, and not deleting unneeded tests. Over time, the test suite becomes larger and more expensive to run while also becoming steadily less effective. This project introduces a novel solution to this problem by giving individual tests …",
A Data Flow Analysis Framework for Data Flow Subsumption,"Marcos Lordello Chaim, Kesina Baral, Jeff Offutt",2021/1,Journal arXiv e-prints,"Data flow testing creates test requirements as definition-use (DU) associations, where a definition is a program location that assigns a value to a variable and a use is a location where that value is accessed. Data flow testing is expensive, largely because of the number of test requirements. Luckily, many DU-associations are redundant in the sense that if one test requirement (eg, node, edge, DU-association) is covered, other DU-associations are guaranteed to also be covered. This relationship is called subsumption. Thus, testers can save resources by only covering DU-associations that are not subsumed by other testing requirements. In this work, we formally describe the Data Flow Subsumption Framework (DSF) conceived to tackle the data flow subsumption problem. We show that DFS is a distributive data flow analysis framework which allows efficient iterative algorithms to find the Meet-Over-All-Paths (MOP) solution for …",
ISSRE 2020 Doctoral Symposium Keynote: How to Get Your Paper Rejected,Jeff Offutt,2020/10/12,Conference 2020 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW),"My papers have been rejected nearly a thousand times (including by ISSRE 2020). In fact, being rejected is one of my best skills! I am confident that I lead the field of software testing in the number of rejections. In this talk, I try to pass on my knowledge and skills to a younger generation, so that you, too, can aspire to accumulate large piles of rejection messages.",
Message from the TestEd 2020 Chairs,"Birgitta Lindström, Jeff Offutt, Kesina Baral, András Márki",2020,"Conference 2020 IEEE 13th International Conference on Software Testing, Verification and Validation Workshops, 23–27 March 2020 Porto, Portugal",,
Farewell and thanks for all the reviews,Jeff Offutt,2019/6,"Source Software Testing, Verification and Reliability","3. Acquire better quality reviews: Reviewing is hard work, but a good quality review can be incredibly valuable for the authors and the reviewers. A good review should encourage good papers, should find the flaws and point them out in a respectful professional way, and should recognize that even reviewers make mistakes. A disrespectful tone, content-free reviews, rude comments, and lack of clarity do not help the authors or the journal. In the early days, I sent reviews back for revision, marked reviewers as “non-useful,” and gave reviewers direct feedback on their reviews. As much as anything else, I tried to make it clear to young scientists that their reviews contribute to their professional reputation. 4. Special issues to increase diversity: Rob and I actively sought out special issues on topics such as model-based testing, mutation analysis, and testing extra-functional properties. We have also long partnered with the …",
I love journal papers and you should too,Jeff Offutt,2019/5,"Source Software Testing, Verification and Reliability","in Wiley Online Library (wileyonlinelibrary. com). DOI: 10.1002/stvr. 1698 conferences try to “shepherd” papers that need significant revision, but this shepherding is usually nominal and often in name only. I have thrice had papers shepherded. Two times I never heard from whoever was assigned to shepherd my paper, and the third got no feedback from the shepherd, so submitted the final versions without a further check. Twice I have been asked to shepherd a paper, but the authors never sent me an update and the conference published their papers anyway (one was still significantly flawed).",
Teaching an International Distributed Discussion-Based Course,"Jeff Offutt, Birgitta Lindström, Kesina Baral",2019,"Conference The 15th Int'l Conf on Frontiers in Education: Computer Science & Computer Engineering (FECS'19). Las Vegas, USA, 29 July-1 August, 2019","Small discussion-based courses pose several challenges. Low enrollments make the course difficult to justify and can restrict active discussions. Impromptu discussions are hard to encourage. Students come to class tired, not well prepared, reluctant to speak out, or not able to verbalize abstract thoughts fast enough to fully engage. Sometimes a few students dominate the discussions while other students stay silent. This paper describes a novel teaching model that was created to allow one professor to teach the same course at multiple universities. As the course design emerged, the asynchronous online distributed nature of the course turned out to not only solve the initial problem, but also other challenges of discussion-based courses. Instructors and students found this model led to more engagement, increased learning, and higher performance.",
Why do people publish in facade journals?,Jeff Offutt,2018/12,"Source Software Testing, Verification and Reliability","Like many other things, cheating has been disrupted by the web [8]. First, the journals can compare submitted papers with thousands of published papers. Not only can conferences check automatically, they are also very expensive: travel, visas, and high registration fees bias the field against professors from poor universities. These avenues for cheating may be more limited than in the past, but the web also offers a solution. Instead of the 1990s method of putting ink on paper and mailing thick stacks of paper, journals just put bits on a server. Paper was expensive, but bits? They are cheap.",
"SOTL: Test Early, Test Often, Test Small, Test Twice",Jeff Offutt,2018/8/8,Journal Innovations in Teaching & Learning Conference Proceedings,"Many educators claim that students perform better and learn more when tested frequently and given frequent detailed feedback. I have taken this to the extreme by replacing traditional midterm exams with weekly (test often, test often), 10-15 minute (test small), quizzes. I have found that students learn more, retain more, and get better grades when given weekly quizzes than when given one long midterm. I also found additional benefits, including more student engagement and better attendance. In the talk, I will discuss strategies for managing the quizzes and retakes (including special purpose support software I developed), discuss some of the benefits, and provide a handout to summarize key points.",
"Proper references is a matter of scholarship, ethics, and courtesy",Jeff Offutt,2018/5,"Source Software Testing, Verification and Reliability","The problem, of course, is that this does not include the workshop name. There is not even a conference named ICSTW! Of course, this is the publisher's mistake. Several program chairs of major conferences have asked IEEE to stop doing this, without success. They are publishers, not scholars, so maybe they do not understand. But scientists who truly care about scholarship cannot repeat their mistake. We have to correct it. And sometimes it takes work—for one paper, I had to contact the authors to ask which workshop their paper was in.",
Color figures considered harmful,Jeff Offutt,2017/12,"Source Software Testing, Verification and Reliability","This issue contains two papers about test automation. Impediments for Software Test Automation: A Systematic Literature Review, by Wiklund, Eldh, Sundmark, and Lundqvist, provides answers for what makes it difficult to apply test automation through a well thought out tour of relevant literature.(Recommended by Bogden Korel.) GUICop: Approach and Toolset for Specification‐based GUI Testing, by Hammoud, Zaraket, and Masri, presents a solution to the test oracle problem for GUIs. Small changes in the appearance of a GUi can fool automated tests into thinking the new screen is incorrect. This work addresses the problem by using a user‐defined GUI specification.(Recommended by Jane Hayes.) I want to give a very short and direct suggestion to help my less experienced colleagues.",
"Is paper reviewing a transaction, a service, or an opportunity?",Jeff Offutt,2017/6,"Source Software Testing, Verification and Reliability","Srisa‐an, and Gregg Rothermel, presents dynamic analysis algorithms to detect race conditions at the process level. The paper also presents results from a test framework that found race conditions on 24 applications, with reasonable overhead.(Recommended by Sudipto Ghosh.) We all know the value of the peer review system. Reviews help filter good research from bad. They also improve the research and the presentation of the papers. Without high‐quality peer reviewing, readers would need to sift through thousands of uninteresting papers to find two or three that inform them of interesting new ideas and important results. That's the benefit to readers, but why do respected scientists review papers? After all, a good review of a complicated paper requires hours of work, and journals do not pay for that time. At a recent meeting of Wiley editors, I heard a discussion of peer reviewing as if it was purely a …",
Accepting shortened papers hurts science,Jeff Offutt,2017/1,"Source Software Testing, Verification and Reliability","A common conundrum when reviewing conference papers is what to do with papers when the reviewers split, or with papers that were not reviewed quite favorably enough to be accepted, but not quite negatively enough to be rejected. We are a field that strives for consensus, but what to do when we there is no consensus? When this happens, someone always proposes to accept the paper as a short paper. It is not quite “good enough” as is, so maybe it would be fine if the authors just cut the bad parts. Or maybe by taking a shorter version than submitted, it makes it clear to all that this is a marginal paper.“Okay, we can publish it, but only if we hold our noses so the smell won't be too bad.” Really, what is the point? After 30 years of writing papers, reviewing papers, editing papers, and helping organize conferences in all capacities, I strongly believe accepting “short versions” of papers is always a bad idea. Why …",
The Downward Death Spiral Review Process,Jeff Offutt,2016/12,"Source Software Testing, Verification and Reliability","This issue contains a real-time verification paper. A simplification of a real-time verification problem, by Suman Roy, Janardan Misra, and Indranil Saha, presents a technique to simplify the real-time verification problem. The paper describes a reduction from an infinite-sized state problem to a finite-sized state problem that can be solved with model checking.(Recommended by",
Changes to STVR's Editorial Board,Jeff Offutt,2016/8,"Source Software Testing, Verification and Reliability","Generation, by Rojas, Fraser, and Arcuri, uses a large collection of open-source programs to demonstrate that changing the initial seed in a search-based test data generation strategy can have a large effect on the quality of the resulting tests.(Recommended by Giuliano Antoniol.) Finally, Prioritizing Test Cases for Early Detection of Refactoring Faults, by Alves, Machado, Massoni, and Kim, presents a strategy for prioritizing regression tests after changing software to support refactoring.",
"Talk Less, Teach More: Tactics for Converting from Lecture Courses to Active Courses",Jeff Offutt,2016/7/15,Journal Innovations in Teaching & Learning Conference Proceedings,• Timing the class is harder with active exercises• The classroom infrastructure has a major affect• Encouraging collaboration can be challenging• Encouraging diversity of thinking• Changing your habits• Your interaction—deciding when to step in 5. Example exercises (illustrative from my clases)• SWE 632—User Interface Design and Development cs. gmu. edu/~ offutt/classes/632/in-class/week3-eval1A. html cs. gmu. edu/~ offutt/classes/632/in-class/week3-mentalModel. html• SWE 637—Software Testing cs. gmu. edu/~ offutt/softwaretest/edition2/powerpoint/Ch07-1-2-overviewGraphCoverage-active. pptx• SWE 205—Software Usability Analysis and Design cs. gmu. edu/~ offutt/classes/205/in-class/OOtM-Excise-example. html,
How the web resuscitated evolutionary design,Jeff Offutt,2015/12,"Source Software Testing, Verification and Reliability","Fraser and Walkinshaw, turns the notion of criteria on its head, by defining test criteria in terms of the outputs instead of the inputs or source (recommended by Hong Zhu). Both inventions can improve test automation, and thus enhance our ability to have evolutionary design. One of my favorite oldies, The Design of Everyday Things, discusses evolutionary design. It caused me to consider what this concept means to software design, development, and testing. I want to start with cost.",
"Globalization–logical flow, motivation, and assumptions",Jeff Offutt,2014/6,"Source Software Testing, Verification and Reliability","This issue presents three fascinating papers on ensuring the reliability and correct behavior of software. The first, Analysis and testing of black-box component-based systems by inferring partial models, by Shahbaz and Groz, tackles the problem of integration testing of component-based software. When components have no specifications, models, or source, testers can only infer proper behavior by trial and error. This paper uses a model learning approach to derive finite state machines that describe observed behavior of the software component.(Recommended by Rob",
Welcome Message from the TTC Workshop Chairs,"Jeff Offutt, Christina Thorpe, Anthony Ventresque",2014/3/1,"Conference 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation Workshops (ICSTW)",Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.,
"Software Testing, Verification and Reliability",Jeff Offutt,2014/3/1,Source SOFTWARE TESTING VERIFICATION & RELIABILITY,,
A tribute to Mary Jean Harrold,Jeff Offutt,2013/12,"Source Software Testing, Verification and Reliability","This issue has three research papers.‘Incremental testing of finite state machines’, by Chaves Pedrosa and Vieira Moura, addresses the scalability problem of designing tests from finite state machines. They use a divide and conquer approach to define combined finite state machines, which allow individual tests to be defined on smaller units and allow test suites to be built incrementally.(Recommended by Byougju Choi.)‘A survey of code-based change impact analysis techniques’, by Li, Sun, Leung, and Zhang, surveys 30 papers that empirically analyzed 23 change impact analysis techniques. The paper synthesizes these results into a structure of four research questions and proposes several new research questions.(Recommended by Jane Hayes.)‘Combining weak and strong mutation for a noninterpretive Java mutation system’, by Kim, Ma, and Kwon, looks at the cost of executing mutants in mutation systems …",
Testing Web Applications,Jeff Offutt,2013/11/26,"Description • Traditional graphs do not apply–Control flow graph C–Call graph• State behavior is hard to model and describe• All inputs go through the HTML UI–low controllability• Hard to get access to server-side state (memory, files, database)–low observability• Not clear what logic predicates can be effectively used• No model for mutation operators on web software","• Traditional graphs do not apply–Control flow graph C–Call graph• State behavior is hard to model and describe• All inputs go through the HTML UI–low controllability• Hard to get access to server-side state (memory, files, database)–low observability• Not clear what logic predicates can be effectively used• No model for mutation operators on web software",
Town hall discussion of SE 2004 revisions (panel),"Mark Ardis, David Budgen, Gregory W Hislop, Jeff Offutt, Mark Sebern, Willem Visser",2013/5/18,Conference 2013 35th International Conference on Software Engineering (ICSE),"This panel will engage participants in a discussion of recent changes in software engineering practice that should be reflected in curriculum guidelines for undergraduate software engineering programs. Current progress in revising the guidelines will be presented, including suggestions to update coverage of agile methods, security and service-oriented computing.",
How to be an STVR reviewer,Jeff Offutt,2013/1/1,Source SOFTWARE TESTING VERIFICATION & RELIABILITY,,
Flipping the testing classroom,Jeff Offutt,2012/12,"Source Software Testing, Verification and Reliability","This issue has three terrific papers. The first paper,‘A testing-based process for component substitutability’, by Flores and Polo, shows us how to test reusable components. The research uses back-to-back testing to evaluate the behaviour of the internal functions of a component, helping the tester decide when a component is stable enough to be reused and when new tests are needed.(Recommended by Sudipto Ghosh.) The second,‘A framework for automatic generation of security controllers’, by Martinelli and Matteucci, addresses the problem of guaranteeing the security of complex systems. This is done through a formal process of modelling components of the systems, then aggregating those models into a security model of the entire complex system.(Recommended by Jeff Offutt.) The third,‘A formal framework to test soft and hard deadlines in timed systems’, by Merayo, Nunez and Rodriguez, presents a …",
"Teaching an Innovative Asynchronous, International, Multi-University Seminar",Jeff Offutt,2012/9/21,Journal Innovations in Teaching & Learning Conference Proceedings,"SWE 763, Software Engineering Experimentation, was taught in spring 2012 as a unique and innovative international collaboration. It used asynchronous lectures and discussions and virtually merged students from US and Swedish universities via Piazza. The class had three weeks of lectures (made available online), ten weeks of reading and discussing research papers, and two weeks of student presentations. Two students wrote and posted summaries and evaluations for each paper, one student Ã¢ â¬ Ådissented, Ã¢ â¬ Â and all students joined the online discussion. This session will describe the innovative aspects of the class, including innovations that were introduced Ã¢ â¬ Åon the flyÃ¢ â¬ Â to solve unanticipated problems, and discuss the advantages, challenges, and disadvantages of this format.",
Status and Awards,Jeff Offutt,2012/6,"Source Software Testing, Verification and Reliability","This issue has three interesting papers about test design. The first paper in this issue, Automated Functional Testing of Online Search Services, by Zhou, Zhang, Hagenbuchner, Tse, Kuo, and Chen, tests search engines. A major problem that is addressed is the ‘oracle function’, which for these applications means how can we know whether the search results are ‘correct’(recommended by Byoungju Choi). The second, Automated Verification and Testing of User-interactive Undo Features in Database Applications, by Ngo and Tan, addresses the problem of testing the ability for users to undo operations. A correspondence between program statements that raise erroneous effects and program statements that can undo those effects is reported and is used to develop a verification technique (recommended by Shaoying Liu). The third, Testing Aspect-oriented Programs with Finite State Machines, by Xu, El-Ariss, Xu …",
Non‐expert reviews considered helpful,Jeff Offutt,2012/5,"Source Software Testing, Verification and Reliability","This issue has three innovative papers. In a belated implementation of a decision made at a meeting of STVR’s editorial board, this issue will start naming the reviewing editor who took charge of each paper. So when you read ‘recommended by’later, that identifies the reviewing editor who found reviewers, evaluated the paper and the reviews and made a recommendation to the co-editors in chief. This is immensely more work than it may seem on the surface, and we are happy to acknowledge the reviewing editors’ hard work. The first paper in this issue, A testing strategy for abstract classes, by Clarke, Power, Babich and King, reports on a landmark advance in object-oriented testing. The authors have invented a way to test abstract classes without having to instantiate the class, thereby giving users more confidence when they create inheritance hierarchies. This is recommended by Atif Memon. The second, Test …",
Guest authors are not welcome,Jeff Offutt,2012/3/1,Journal SOFTWARE TESTING VERIFICATION & RELIABILITY,,
ICST 2009 special issue,"Jeff Offutt, Per Runeson",2011/9,"Source Software Testing, Verification and Reliability","This special issue contains extended versions of four papers from the second IEEE International Conference on Software Testing Verification and Validation (ICST 2009). These four papers were selected based on the reviews from members of the program committee and subsequently subjected to additional rounds of review and revision. We issued 10 invitations to this special issue. Three authors declined to submit, two were not selected after submission, one chose not to revise the paper after being reviewed, and four papers were eventually accepted.",
Status of the journal,Jeff Offutt,2011/6,"Source Software Testing, Verification and Reliability","On the use of a similarity function for test case selection in the context of model-based testing, by Cartaxo, Machado, and Neto, uses a similarity function to reduce model-based tests that are redundant in terms of their coverage. The second, Fault-driven stress testing of distributed realtime software based on UML models, by Garousi, presents a new way to apply stress testing to evaluate real-time constraints in distributed software. The third, On the selection of software defect estimation techniques, by Cangussu, Haider, Cooper, and Baron, introduces a new methodology to analyze techniques for estimating defects in software. I would like to use this editorial to give a brief status report of the journal, starting with a major announcement. Effective immediately, Rob Hierons of Brunel University will join me as a second Editor-in-Chief. Rob has helped run STVR for years and his willingness to take on additional …",
Ethics and Publishing,Jeff Offutt,2010/12,"Source Software Testing, Verification and Reliability","This issue has two papers with unusual author lists: Roger T. Alexander, Jeff Offutt and Andreas Stefik for the first; and Jane Huffman Hayes and Jeff Offutt for the second. Both papers were submitted before I became EiC and both were handled by Associate Editor Rob Hierons. Effective and sufficient controls were in place to ensure there was no conflict in their handling. It is important to emphasize three points:",
Agility must be good for testing,Jeff Offutt,2010/9,"Source Software Testing, Verification and Reliability","Unless you’ve been hiding or never look outside of academia, you must have seen the wave of agile processes that have been sweeping the software industry. Is the term agile process just one more of the hundreds of buzzwords that have made the rounds, only to disappear in obscurity, or does it describe something that will have a lasting positive impact on software development? If you hope for an answer to that question here, I am no fool to make such a rash prediction. I am neither an advocate nor a critic of agile processes, and not knowledgeable enough to be either. My mind is truly open on this subject. Through my students and other industrial contacts, I have talked with numerous people who applied an agile process correctly and thought it helped very much. I have also talked with people who failed miserably with an agile process. Many of them seem to have applied the process incorrectly.",
"People are approximators, not perfectors",Jeff Offutt,2010/6,"Source Software Testing, Verification and Reliability","I recently read Norman’s classic book, The Design of Everyday Things [1]. Though 22-years old, it’s an excellent read and still very relevant. One point Norman made is that people are good at approximations, but not at being perfect. This cognitive aspect of people affects the design and production of everyday things (and software).",
Testing my new building,Jeff Offutt,2009/12,"Source Software Testing, Verification and Reliability","This issue has two exciting papers. The first, Modelling methods for web application verification and testing: state of the art, by Alalfi, Cordy and Dean, provides a comprehensive survey of models that are used to help us evaluate the quality of web applications. The second, System testing for object-oriented systems with test case prioritization, by Kundu, Sarma, Samanta and Mall, presents a method to generate tests from UML sequence diagrams. I recently moved into a new building, and not surprisingly, it made me think about testing.(Right, everything does.) Although I am happy here, it has its flaws like any building. Lots of people have drawn analogies between software engineering and civil engineering, and I took this opportunity to reflect on how the analogy applies to testing.",
TAIC PART 2007 and Mutation 2007 special issue editorial,"Mark Harman, Zheng Li, Phil McMinn, Jeff Offutt, John Clark",2009/11/1,Journal Journal of Systems and Software,"Software testing is a topic of growing importance because of the central role it plays in so many aspects of software engineering, both pre–and post–delivery. There is strong empirical evidence [1, 2] that deficient testing of both functional and non-functional properties is one of the major sources of software and system errors. In 2002, NIST estimated the cost of software failure to the US economy at $60,000,000,000; an astonishing 0.6% of GDP [3]. The same report found that more than one third of these costs of software failure could be eliminated by an improved testing infrastructure. As these data reveal, the importance of work on software testing and its potential impact on the global economy is hard to overstate.",
confidentiality and plagiarism,Jeff Offutt,2009/9,"Source Software Testing, Verification and Reliability","This issue has three interesting papers. The first, Integrating testing with reliability, by Schneidewind, explores issues at the intersection of testing and reliability, with the goal of discovering which test techniques have the strongest impact on reliability. The second paper, Inclusion, subsumption, JJ-paths, and structured path testing: a redress, by Yates and Malevris, explores the JJ-path (LCSAJ) test coverage criterion, correcting errors in previously published theoretical statements about JJ-paths inclusion relationships with other test coverage criteria. The third paper, Testing with model checkers: a survey, by Fraser, Wotawa, and Ammann, provides a comprehensive survey of how model checkers have been applied to software testing problems. A few years ago I attended a lecture by Professor Robert B. Laughlin, physics Nobel Laureate. He said that ‘globalization imposes a tax on young people—they have to learn …",
"Keynote: Automatic Test Data Generation: Who, When and Where?",Jeff Offutt,2009/7/8,Conference 2009 Third IEEE International Conference on Secure Software Integration and Reliability Improvement,"The past decade has seen exciting changes in how we develop and test software. Researchers have invented numerous techniques and criteria that are now mature enough to be ready for industrial use. During this time, the need for reliable software has grown enormously. The user base is expanding, technological advances put software into more mission-critical locations, software continues to grow in complexity, and secure software must be correct software. However, many of the strongest testing ideas invented by researchers have not yet been adopted by industry. In particular, one of the hardest problems in software testing is automatic generation of test inputs; a problem with many sophisticated solutions from the research community but for which industry tools only have primitive solutions. This talk will discuss automatic test data generation in the context of the model-driven test design process, then discuss …",
Running a conference program meeting in the 21st century,Jeff Offutt,2009/6,"Source Software Testing, Verification and Reliability","I am drafting this editorial from the second IEEE International Conference on Software Testing, Verification and Validation (ICST 2009), where I am serving as the program co-chair. STVR has committed to publishing a special issue each year of the best papers published in this important new testing conference. Since this editorial was due during the conference, I decided to write about the conference management.",
Is software testing essential or accidental?,Jeff Offutt,2009/3,"Source Software Testing, Verification and Reliability","This issue contains three papers. Automatic instantiation of abstract tests on specific configurations for large critical control systems, by Flammini, Mazzocca, and Orazzo, proposes the interesting idea of creating abstract tests from system requirements and automatically instantiating them into concrete tests. Transition covering tests for systems with queues, by Huo and Petrenko, proposes another technique to automatically generate tests, this time for concurrent systems. Generating input data structures for automated program testing, by Chung and Bieman, studies another aspect of automatic test data generation, describing how statements are connected in terms of constraints that can be solved to yield test inputs. The common theme in these three papers is that they are trying to find automated ways to solve the hardest essential problem in testing software—generating test input values.",
The Logical Choice,"Graham Hutton, Luca Aceto, Anna Ingólfsdóttir, Kim Guldstrand Larsen, Jiri Srba, Jonathan Jacky, Margus Veanes, Colin Campbell, Wolfram Schulte, Paul Ammann, Jeff Offutt",2009,"Description Theory and Practice of Logic Programming is an international journal that publishes refereed papers covering both the theory and the practice of logic programming. Among the topics covered are AI applications that use logic programming, logic programming methodologies, specification, analysis and verification of systems, inductive logic programming, multi-relational data mining, natural language processing, knowledge representation, nonmonotonic reasoning, semantic web reasoning, databases, implementations and architectures and constraint logic programming. TPLP is the sole official journal of the Association for Logic Programming (http://www. cs. kuleuven. be/~ dtai/projects/ALP) and is offered to its members at a preferential rate. It is also endorsed by SPARC, the Scholarly Publishing & Academic Resources Coalition (URL: www. arl. org/sparc).","Theory and Practice of Logic Programming is an international journal that publishes refereed papers covering both the theory and the practice of logic programming. Among the topics covered are AI applications that use logic programming, logic programming methodologies, specification, analysis and verification of systems, inductive logic programming, multi-relational data mining, natural language processing, knowledge representation, nonmonotonic reasoning, semantic web reasoning, databases, implementations and architectures and constraint logic programming. TPLP is the sole official journal of the Association for Logic Programming (http://www. cs. kuleuven. be/~ dtai/projects/ALP) and is offered to its members at a preferential rate. It is also endorsed by SPARC, the Scholarly Publishing & Academic Resources Coalition (URL: www. arl. org/sparc).",
Software testing is an elephant,Jeff Offutt,2008/12,"Source Software Testing, Verification and Reliability","This issue contains two papers. The first, An analysis technique to increase testability of objectoriented components, by Kansomkeat and Rivepiboon, examines the problem of testability of object-oriented software components when the source is not available but something like bytecode is. OO components have low testability because information hiding obscures the state that needs to be controlled and monitored during testing. This research uses a clever idea of extracting a control and data flow graph, which is then used to increase both controllability and observability, making it easier to detect faults. The second paper, The determination of optimal software release times at different confidence levels with consideration of learning effects, by Ho, Fang and Huang, uses stochastic differential equations to build a software reliability model. This model is validated on data that were published in six previous papers …",
Science Fiction and Fantasy,Jeff Offutt,2008/9,"Source Software Testing, Verification and Reliability","This issue contains two papers. The first, IPOG/IPOG-D: Efficient test generation for multi-way combinatorial testing, by Lei, Kacker, Kuhn, Okun and Lawrence, presents two new strategies for t-way combinatorial testing. The strategies have been implemented in a tool, FireEye, which is available on the first author’s website. Software engineering researchers have always developed tools, but most tools have not been easily available to other researchers. This positive trend has the ability to multiply the impact of our research. The second, Reconciling perspectives of software logic testing, by Kaminski, Williams and Ammann, describes a rather large family of test criteria based on covering logical expressions. Logical expressions are essential to software at all levels—requirements, specifications, design, and implementation. These logic test criteria attempt to cover logical expressions in various ways. The paper …",
Generating Trace-Sets for Model-based Testing,"Paul Pettersson, Jeff Offutt",2007/11/29,Conference null,"Model-checkers are powerful tools that can find individual traces through models to satisfy desired properties. These traces provide solutions to a number of problems. Instead of individual traces, software testing needs sets of traces that satisfy coverage criteria.Finding a trace set in a large model is difficult because model checkers generate single traces and use a lot of memory. Space and time requirements of modelchecking algorithms grow exponentially with respect to the number of variables and parallel automata of the model being analyzed.We present a method that generates a set of traces by iteratively invoking a model checker. The method mitigates the memory consumption problem by dynamically building partitions along the traces. This method was applied to a testability case study, and it generated the complete trace set, while ordinary model-checking could only generate 26%.",
Introduction and plans for the future,Jeff Offutt,2007/6,"Source Software Testing, Verification and Reliability","This is my first editorial after taking over the journal in October of last year. Assuming the responsibility for a successful major journal like STVR is both exhilarating and daunting. It seems just a few weeks ago I was a student, wondering if I could ever get journals like TSE or CACM to publish my papers, but it has actually been 20 years. One of the most exciting events in that time was the creation of STVR in 1991. Authors and readers of STVR owe a debt of gratitude to Derick Yates for founding the journal, to Lee White for serving as North American editor for 16 years and Martin Woodward for serving as editor-in-chief for 15 years. They created and built an excellent journal that has greatly helped the field of software testing. At a more personal level, I am grateful for the confidence that both Martin and Lee showed in asking me to take over first as North American editor, then as editor-in-chief. This is an exciting time …",
"Reflections on the past, present and future","Martin Woodward, Jeff Offutt",2007/3,"Source Software Testing, Verification and Reliability","This issue of STVR marks my first as Chief Editor. Shortly before this issue went to press, we unexpectedly and posthumously received an almost completed editorial from the outgoing editor, Martin Woodward. I decided to publish this, his last, editorial as I believe he wished. It includes thoughtful and sometimes poignant thoughts on his many years of experience as Chief Editor. I plan to introduce my plans and goals for the journal in the following issue. The following words are Martin’s.",
A Tribute to Martin Woodward,"Lee White, Jeff Offutt, Derek Yates, Rob Hierons, Michael Hennell, Peter Mitchell",2006/12,"Journal Software Testing, Verification and Reliability","As this issue of STVR was going to press, we were all shocked by the sudden death of Martin Woodward on October 27, 2006. As you can see from the Editorial in this issue written by Lee White, a new Chief Editor had been named on the announcement of the retirement of both Martin Woodward and Lee White as Editors of STVR; that new Chief Editor is Jeff Offutt. Martin was planning to write an Editorial for the next issue, 17 (1), of STVR to explain his resignation as Editor, and to share other thoughts on his experiences as Chief Editor of the Journal. Since Martin will not have that opportunity, several of us would like to offer a tribute to Martin and to share some of our experiences with him over the last 13 years.",
Empirical Evaluation of Coupling-based Testing Techniques for Object-oriented Programs,"Roger T Alexander, Jeff Offutt",2004/5/3,"Description Object-oriented design has caused a shift in focus from software units to the way software classes and components are connected. Thus, we are finding that we need less emphasis on unit testing and more on integration testing. The compositional relationships of inheritance and aggregation, especially when combined with polymorphism, introduce new kinds of integration faults, which cannot be covered unless testers use test criteria that specifically evaluate inheritance and polymorphism. This paper results from a set of experiments on the relative effectiveness of several coupling-based OO testing criteria and branch coverage. Tests developed according to the criteria were evaluated on programs seeded with faults that are specific to object-oriented programs. The paper uses a statistical analysis technique, log-linear analysis, that has not been widely used in software engineering but that is more applicable than analysis of variance in situations where the sample space is not well understood (such as with software). The data indicate that the OO criteria are all much more effective at detecting faults due to the misuse of inheritance and polymorphism than branch coverage.","Object-oriented design has caused a shift in focus from software units to the way software classes and components are connected. Thus, we are finding that we need less emphasis on unit testing and more on integration testing. The compositional relationships of inheritance and aggregation, especially when combined with polymorphism, introduce new kinds of integration faults, which cannot be covered unless testers use test criteria that specifically evaluate inheritance and polymorphism. This paper results from a set of experiments on the relative effectiveness of several coupling-based OO testing criteria and branch coverage. Tests developed according to the criteria were evaluated on programs seeded with faults that are specific to object-oriented programs. The paper uses a statistical analysis technique, log-linear analysis, that has not been widely used in software engineering but that is more applicable than analysis of variance in situations where the sample space is not well understood (such as with software). The data indicate that the OO criteria are all much more effective at detecting faults due to the misuse of inheritance and polymorphism than branch coverage.",
Categorization of Common Coupling and Its Application to the Maintainability of the Linux Kernel,"Yu Liguo, R Schach Stephen, Chen Kai, Jeff Offutt",2004,Publisher the IEEE Computer Society,"Data coupling between modules, especially common coupling, has long been considered a source of concern in software design, but the issue is somewhat more complicated for products that are comprised of kernel modules together with optional nonkernel modules. This paper presents a refined categorization of common coupling based on definitions and uses between kernel and nonkernel modules and applies the categorization to a case study. Common coupling is usually avoided when possible because of the potential for introducing risky dependencies among software modules. The relative risk of these dependencies is strongly related to the specific definition-use relationships. In a previous paper, we presented results from a longitudinal analysis of multiple versions of the open-source operating system Linux. This paper applies the new common coupling categorization to version 2.4.20 of Linux, counting …",
Software Design and implementation,Jeff Offutt,2004,Journal The Internet Encyclopedia,"292 293 293 294 295 295 to present information to visitors and occasionally ob-tain information from them with forms (Powell, 1998). Figure 1 illustrates this scenario. A client was a Web browser that people used to visit Web sites. The Web sites were on separate computers, the servers, which delivered HTML files to the client. HTML forms generated data that were sent back to the server to be processed by CGI pro-grams. This is a simple execution model that supports rel-atively small web sites. The software involved is by neces-sity small in scale; such Web sites usually cannot support much load and offer limited functionality. The software also has few provisions for security, and the TCP (trans-mission control protocol) and HTTP (hypertext transfer protocol) by themselves are not designed to support se-cure interactions.",
An Empirical Evaluation of Maintaining Evolving Component-based Software with the UML,"Ye Wu, Jeff Offutt, Yuqin Ding",2003,"Description Unlike traditional systems, many components of component-based software are maintained by third-party providers and the maintenance is invisible to component users. Even though the modified components may still keep the same interfaces, internal changes may adversely affect systems that use the components. Regression testing of the existing systems that integrate with modified components must be done carefully despite the fact that the component users do not have access to the source. In a previous paper, we presented a method to model changes to components and then derive regression tests based on those changes [5]. This fast abstract presents results from an empirical evaluation of that regression testing technique. The changes are modeled by using the Unified Modeling Language (UML). We first establish a UML-based infrastructure to model different types of changes. Then regression-testing strategies are developed to try to validate these changes. This experimental evaluation applies the change modeling technique to a small system. The changes were modeled by UML collaboration diagrams and state charts, tests were generated based on several criteria, faults were inserted into (a changed version of) the implementation, and the tests were evaluated by their ability to detect the faults.","Unlike traditional systems, many components of component-based software are maintained by third-party providers and the maintenance is invisible to component users. Even though the modified components may still keep the same interfaces, internal changes may adversely affect systems that use the components. Regression testing of the existing systems that integrate with modified components must be done carefully despite the fact that the component users do not have access to the source. In a previous paper, we presented a method to model changes to components and then derive regression tests based on those changes [5]. This fast abstract presents results from an empirical evaluation of that regression testing technique. The changes are modeled by using the Unified Modeling Language (UML). We first establish a UML-based infrastructure to model different types of changes. Then regression-testing strategies are developed to try to validate these changes. This experimental evaluation applies the change modeling technique to a small system. The changes were modeled by UML collaboration diagrams and state charts, tests were generated based on several criteria, faults were inserted into (a changed version of) the implementation, and the tests were evaluated by their ability to detect the faults.",
An Industrial Case Study: Using CACC to Test Real-time Embedded Software1,"Jing Guan, Jeff Offutt",2003,"Description Correlated Active Clause Coverage (CACC) is a test criterion whose goal is to test individual clauses within logical expressions [1]. Although considered to be expensive, the FAA requires its close cousin, Multiple Condition Decision Coverage (MCDC), to be used to test safety-critical parts of aeronautics software [3]. This fast abstract presents results from a case study of CACC on a safety-critical, real-time embedded transportation control system. Our study compared CACC testing with functional testing. We found that the CACC test cases detected important faults that were not detected by functional testing, and that would be very difficult to detect by any other testing technique.","Correlated Active Clause Coverage (CACC) is a test criterion whose goal is to test individual clauses within logical expressions [1]. Although considered to be expensive, the FAA requires its close cousin, Multiple Condition Decision Coverage (MCDC), to be used to test safety-critical parts of aeronautics software [3]. This fast abstract presents results from a case study of CACC on a safety-critical, real-time embedded transportation control system. Our study compared CACC testing with functional testing. We found that the CACC test cases detected important faults that were not detected by functional testing, and that would be very difficult to detect by any other testing technique.",
Future of mutation testing and its application (panel session),"John Clark, Rich DeMillo, Dick Lipton, Martin Woodward",2001/5/1,Book Mutation testing for the new century,,
Panel Future of Mutation Testing and Its Application,Jeff Offutt,2001,Journal Mutation Testing for the New Century,,
"Proceedings Seventh IEEE International Conference on Engineering of Complex Computer Systems: Skövde, Sweden, June 11-13, 2001","Sten F Andler, Michael G Hinchey, Jeff Offutt",2001,Publisher The Society,,
Software testing and analysis of object-oriented software,Jeff Offutt,2000/1/1,Journal ACM SIGSOFT Software Engineering Notes,"Our work has studied new language mechanisms for accessing message invocations in message passing based concurrent programming languages. Invocation handling mechanisms in many concurrent languages have significant limitations that make it difficult or costly to solve common programming situations encountered in program visualization, debugging, and scheduling scenarios. We have defined and implemented new such mechanisms within the SR concurrent language and have gained some experience with them.This work has led us to want a cleaner, higher-level way of defining mechanisms for message invocation. We are, therefore, now taking an object-oriented approach. As a step toward that goal, we are currently applying our ideas to Java.Below, we briefly summarize these two areas.",
開発技術,"Liu Shaoying, AJeff Offutt, Ohba Mitsuru, Araki Keijiro",1998/6/15,Journal 情報処理学会論文誌,"In this paper we point out three major deficiencies of data flow diagrams (DFDs) for requirements analysis. One is the impracticability of the rule for decomposing processes another is the inconvenience of drawing data flows for complex DFDs and the third is the lack of precision in process specifications. We present an improved approach using SOFL (Structured-Object-oriented-Formal Language) to show how these deficiencies can be addressed. This approach can be applied to make the use of DFDs more practical scalable and more accessible to industrial users. In this paper we point out three major deficiencies of data flow diagrams (DFDs) for requirements analysis. One is the impracticability of the rule for decomposing processes, another is the inconvenience of drawing data flows for complex DFDs, and the third is the lack of precision in process specifications. We present an improved approach using SOFL (Structured-Object-oriented-Formal Language) to show how these deficiencies can be addressed. This approach can be applied to make the use of DFDs more practical, scalable, and more accessible to industrial users.",
The SOFT Approach: An Improved Principle for Requirements Analysis (Special Issue on Parallel Processing),"Shaoying Liu, A JEFF OFFUTT, MITSURU OHBA, KEIJIRO ARAKI",1998/6/15,Journal 情報処理学会論文誌,,
"SOFL: A formal engineering methodology for industrial applications (vol 24, pg 24, 1998)","SY Liu, AJ Offutt, C Ho-Stuart",1998/5/1,Journal IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,,
"Correction to"" An Empirical Evaluation of Weak Mutation""","A Jefferson Offutt, Stephen D Lee",1994/9/1,Journal IEEE Trans. Software Eng.,"The IEEE TRANSACTIONS ON SOFIWARE ENGINEERING is an archival joum’al published monthly. We are interested in well-defined theoretical results and empirical studies that have potential impact on the construction, analysis, or management of software. The scope of this TRANSACTIONS ranges from the mechanisms, from the development of principles to the application of those principles to specific environments. Since the joumal is archival, it is assumed that the ideas presented are important, have been will analyzed, and/or empirically validated and are of value to the software engineering research or practitioner community.",
Panel: Empirical Techniques for Assessing Testing Strategies,"E Weyuker, R Carver, P Frankl, J Offutt",1994,Journal SOFTWARE ENGINEERING NOTES,,
"Towards Conservative Reliability Predictions for Real-time Software: Final Report NASA Research Grant, NAG-1-1024","Robert M Geist, A Jefferson Offutt, Frederick C Harris",1991,Publisher Clemson University,,
Towards conservative reliability predictions for real-time software(Final Report),"ROBERT GEIST, AJEFFERSON OFFUTT, FREDE HARRIS, J R I C K C",1991,"Description A method for obtaining numerical estimates of the reliability of N-version, real-time software is proposed. An extended stochastic Petri net is used to represent the synchronization structure of N versions of the software, where dependencies among versions are modeled through correlated sampling of module execution times. The distributions of execution times are derived through an automated generation of test cases that is based on mutation analysis. Since these test cases are designed to reveal software errors, the associated execution times are likely to provide a worst case scenario. Experimental results using specifications for NASA's planetary lander control software suggest that mutation-based testing could hold greater potential for reliability enhancement than the desirable but perhaps unachievable goal of independence among N versions. (Author)","A method for obtaining numerical estimates of the reliability of N-version, real-time software is proposed. An extended stochastic Petri net is used to represent the synchronization structure of N versions of the software, where dependencies among versions are modeled through correlated sampling of module execution times. The distributions of execution times are derived through an automated generation of test cases that is based on mutation analysis. Since these test cases are designed to reveal software errors, the associated execution times are likely to provide a worst case scenario. Experimental results using specifications for NASA's planetary lander control software suggest that mutation-based testing could hold greater potential for reliability enhancement than the desirable but perhaps unachievable goal of independence among N versions. (Author)",
Comments on Tai,A Jefferson Offutt,1990/1/1,Journal ACM SIGSOFT Software Engineering Notes,,
Environmental Rural Sanitation with Special Reference to School Environment,Andrew J Offutt,1952,Institution University of Kentucky,,
2022 IEEE/ACM 44th International Conference on Software Engineering: Software Engineering Education and Training (ICSE-SEET)| 978-1-6654-9592-9/22/$31.00© 2022 IEEE| DOI: 10 …,"Abasi-amefon O Affia, Manal M Alhammad, Eduardo Aranha, Kesina Baral, Diane C Bates, Andrew Begel, Jan Philip Bernius, Daria Bogdanova, Christopher Bohn, Bernd Bruegge, Håkan Burden, Ethan Butt, Konstantin Chaika, Robert Chatley, Michel RV Chaudron, Stephen Cooper, Luis Corral, Benjamin Ultan Cowley, Jialin Cui, James Dominic, Kaj Dreef, John Edwards, Sebastian Elbaum, Madeline Endres, Samuel Ferino, Anny Fernandes, Marcelo Fernandes, Ilenia Fronza, Benjamin Kok Siew Gan, Edward Gehringer, Bhuvaneswari Gopal, Iris Groher, Marco Gutfleisch, Arto Hellas, Carl Hildebrandt, Alexander Hofer, Petri Ihantola, Qinjin Jia, Jussi Kasurinen, Barbara Kitchenham, Ella Kokinda, Kirill Krinkin, Stephan Krusche, Lisa Kuka, Uirá Kulesza, Emily Laue Christensen, Jason Lehmann, Margaret E Leigey, Juho Leinonen, Valentina Lenarduzzi, Annie Li, Ruochi Li, Chengyuan Liu, David Lo, Kaida Lou, Roope Luukkainen, Bang D Mach, Raimundas Matulevičius, Adriana Meza Soria, Supriya Mishra, Ana M Moreno, Makayla Moster, David Muster, Uolevi Nikula, Alexander Nolte, Jeff Offutt, Eng Lieh Ouh, Maria Paasivaara, Claus Pahl, Kim Pearson, Suzette Person, Sebastián Pizard, S Monisha Pulimood, Matthew Re","Author Index Toggle navigation IEEE Computer Society Digital Library Jobs Tech News 
Resource Center Press Room Advertising About Us IEEE IEEE Computer Society IEEE 
Computer Society Digital Library My Subscriptions Magazines Journals Conference Proceedings 
Institutional Subscriptions IEEE IEEE Computer Society More Jobs Tech News Resource Center 
Press Room Advertising About Us Cart All Advanced Search Conference Cover Image 
Download 1.Home 2.Proceedings 3.icse-seet 2022 Author Index 2022, pp. 277-278, DOI 
Bookmark: 10.1109/ICSE-SEET55299.2022.9794267 Keywords Authors Abstract Presents the 
author index for the conference. Author IndexAffia, Abasi-amefon O. 134Alhammad, Manal M. 
146Aranha, Eduardo 90Baral, Kesina 82Bates, Diane C. 14Begel, Andrew 50Bernius, Jan Philip 
113Bogdanova, Daria 25Bohn, Christopher 254Bruegge, Bernd 113Burden, Håkan 176Butt, …","Scholar articles 2022 IEEE/ACM 44th International Conference on Software Engineering: Software Engineering Education and Training (ICSE-SEET)| 978-1-6654-9592-9/22/$31.00© 2022 IEEE| DOI: 10.1109/ICSE-SEET55299. 2022.9794267AO Affia, MM Alhammad, E Aranha, K Baral, DC Bates…All 2 versions ",,
ISSRE 2020 Doctoral Symposium Committees,"Carol Smidts, Hélène Waeselynck, Jeff Offutt, Holger Schlingloff, Nuno Antunes, Domenico Cotroneo, Karama Kanoun, Nuno Laranjeiro, Marco Vieira, Mladen Vouk","ISSRE 2020 Doctoral Symposium Committees Toggle navigation IEEE Computer Society Digital 
Library Jobs Tech News Resource Center Press Room Advertising About Us IEEE IEEE 
Computer Society IEEE Computer Society Digital Library My Subscriptions Magazines Journals 
Conference Proceedings Institutional Subscriptions IEEE IEEE Computer Society More Jobs 
Tech News Resource Center Press Room Advertising About Us Cart All Advanced Search 
Conference Cover Image Download 1.Home 2.Proceedings 3.issrew 2020 ISSRE 2020 Doctoral 
Symposium Committees 2020, pp. 19-19, DOI Bookmark: 10.1109/ISSREW51248.2020.00009 
Keywords Authors ISSRE 2020 Doctoral Symposium Committees ISSRE Doctoral Symposium 
Chairs Carol Smidts, The Ohio State University, USA Hélène Waeselynck, LAAS-CNRS, 
France Invited speakers Jeff Offutt, George Mason University, USA Holger Schlingloff…","Scholar articles ISSRE 2020 Doctoral Symposium CommitteesC Smidts, H Waeselynck, J Offutt, H Schlingloff…All 2 versions ",,
Research Project Descriptions,Jeff Offutt,"This NASA and NIST supported project is attempting to develop new ways to test software that powers web applications. Web software systems are built using heterogeneous and very loosely coupled software components. They typically interact by passing messages that exchange data and activity state information. These heterogeneous message transfers are usually structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. This research project is attempting to find ways to validate the reliability of data interactions among web-based software system components, particularly among software components that communicate using XML messages.Two general approaches are being explored at the present time. One is based on the idea of"" information flows"". A significant advantage of web-based software is that it allows data to be transferred among completely different types of software components that reside and execute on different computers. For example, a data item input by a user through a web browser may be transferred through an HTML form to a Java Script for syntax validation, then passed across the internet to a web server, which forms it into a parameter that is given to a Java Servlet. The servlet may do further checking, and then encode the data item in a JavaBean, which may then be serialized and stored to disk either in a flat file or in a commercial database. This data item may also trigger the return of more data from the database, which results in further processing by a Java Servlet. This data may then be formulated as part of an HTML page, and delivered through the web server …",Scholar articles Research Project DescriptionsJ OffuttRelated articles ,"This NASA and NIST supported project is attempting to develop new ways to test software that powers web applications. Web software systems are built using heterogeneous and very loosely coupled software components. They typically interact by passing messages that exchange data and activity state information. These heterogeneous message transfers are usually structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. This research project is attempting to find ways to validate the reliability of data interactions among web-based software system components, particularly among software components that communicate using XML messages.",
1. Question Formulation,"Fabiano Cutigi Ferrari, Jeff Offutt, Leo Fernandes, Márcio Ribeiro",Research Question 1:(RQ1) Which techniques support cost reduction of mutation testing? Research Question 2:(RQ2) Which metrics have been used to measure the cost reduction of mutation testing? Research Question 3:(RQ3) What are the savings (benefit) and loss of effectiveness (as proxied by mutation score) for the techniques?,"Scholar articles 1. Question FormulationFC Ferrari, J Offutt, L Fernandes, M RibeiroRelated articles All 2 versions ",Research Question 1:(RQ1) Which techniques support cost reduction of mutation testing? Research Question 2:(RQ2) Which metrics have been used to measure the cost reduction of mutation testing? Research Question 3:(RQ3) What are the savings (benefit) and loss of effectiveness (as proxied by mutation score) for the techniques?,
Program Committee for SER&IP 2018,"Aiko Yamashita, Amanda Jane Gregory, Avinash Kak, Bjorn Lundell, Emilie Engström, Freddy Munoz, Jan Bosch, Jason Zhang, Jeff Offutt, Jorge Cuellar, Judith Bishop, Laurence Duchien, Luciano Baresi, Matt Staats, Nachi Nagappan, Paddy Krishnan, Ravi Khadka, Razieh Behjati, Sagar Sen, Sanjai Rayadurgam, Veronika Bauer, Vinay Kulkarni, Xiao Qu, Yoshiki Mitani, Yuetang Deng","Program Committee for SER&IP 2018 Toggle navigation IEEE Computer Society Digital Library 
Jobs Tech News Resource Center Press Room Browse By Date Advertising About Us IEEE 
IEEE Computer Society IEEE Computer Society Digital Library My Subscriptions Magazines 
Journals Conference Proceedings Institutional Subscriptions IEEE IEEE Computer Society 
More Jobs Tech News Resource Center Press Room Browse By Date Advertising About Us 
Cart All Advanced Search Conference Cover Image Download 1.Home 2.Proceedings 3.ser&ip 
2018 Program Committee for SER&IP 2018 2018, pp. 12-12, DOI Bookmark: Keywords Authors 
,Program Committee for ,SER&IP 2018 , , ,Aiko Yamashita ,Oslo and Akershus University of 
,Applied Sciences ,Norway , ,Amanda Jane Gregory ,University of Central Lancashire ,UK 
, ,Avinash Kak ,Purdue University ,USA , ,Bjorn Lundell ,University of Skövde ,Sweden , ,…","Scholar articles Program Committee for SER&IP 2018A Yamashita, AJ Gregory, A Kak, B Lundell…All 2 versions ",,
A-MOST 2018,"Paolo Arcaini, Xavier Devroey, João Pascoal Faria, Rob Hierons, Manuel Núñez, Alexander Pretschner, Bernhard Aichernig, Shaukat Ali, Moussa Amrani, Aitor Arrieta Marcos, Kirill Bogdanov, Fabrice Bouquet, Frédéric Dadeau, Sudipto Ghosh, Bruno Legeard, Levi Lúcio, Mercedes Merayo, Brian Nielsen, Jeff Offutt, Ana Paiva, Mike Papadakis, Ioannis Parissis, Gilles Perrouin, José Miguel Rojas, Shuai Wang, Franz Wotawa, Tao Ma","A-MOST 2018 Committees Toggle navigation IEEE Computer Society Digital Library Jobs Tech 
News Resource Center Press Room Browse By Date Advertising About Us IEEE IEEE 
Computer Society IEEE Computer Society Digital Library My Subscriptions Magazines Journals 
Conference Proceedings Institutional Subscriptions IEEE IEEE Computer Society More Jobs 
Tech News Resource Center Press Room Browse By Date Advertising About Us Cart All 
Advanced Search Conference Cover Image Download 1.Home 2.Proceedings 3.icstw 2018 
A-MOST 2018 Committees 2018, pp. 23-23, DOI Bookmark: 10.1109/ICSTW.2018.00014 
Keywords Authors Abstract Provides a listing of current committee members and society officers. 
A-MOST 2018 ,Organizing and Program Committee Members, , ,General Program chairs, 
,Paolo Arcaini, ,National Institute of Informatics, Japan, ,Xavier Devroey, ,Delft University of …","Scholar articles A-MOST 2018P Arcaini, X Devroey, JP Faria, R Hierons, M Núñez…All 2 versions ",,
ICSTW 2018,"Fabiano Cutigi Ferrari, Alessandro Viola Pizzoleto, Jeff Offutt, Rahul Gopinath, Björn Mathis, Andreas Zeller, Alex Denisov, Stanislav Pankevich","Table of contents Page 1 2018 IEEE International Conference on Software Testing, Verification 
and Validation Workshops ICSTW 2018 Table of Contents Message from the ICST 2018 
Program Chairs xi Message from the Mutation 2018 General Chairs xiii Mutation 2018 
Committees xiv Message from the ITEQS 2018 Workshop Chairs xv ITEQS 2018 Committees xvi 
Message from the VVIoT 2018 Chairs xvii VVIoT 2018 Committees xviii Welcome Message and 
Committees for NEXTA 2018 xix Message from the A-MOST 2018 General Chairs xxii A-MOST 
2018 Committees xxiii Message from the InSTA 2018 Chairs xxiv InSTA 2018 Committees xxv 
Message from the IWCT 2018 Workshop Chairs xxvi IWCT 2018 Committees xxviii Message 
from the TAIC PART 2018 Chairs xxix TAIC PART 2018 Committees MUTATION 2018 A 
Systematic Review of Cost Reduction Techniques for Mutation Testing: Preliminary Results …","Scholar articles ICSTW 2018FC Ferrari, AV Pizzoleto, J Offutt, R Gopinath, B Mathis…",,
SER&IP 2016,"Rakesh Shukla, Sagar Sen, Linda Laird, Judith Bishop, Waqas Moazzam, Aiko Yamashita, Amanda Jane Gregory, Avinash Kak, Barbara Russo, Bill Curtis, Bran Selic, Carlos Jensen, Freddy Munoz, Gregory Nain, Hong Zhang, Ivica Crnkovic, Jeff Offutt, June Andronick, Luciano Baresi","We cheerfully welcome you to the 3rd International Workshop on Software Engineering Research and Industrial Practice, held this year in Austin, Texas. The aim of our workshop is to bring together researchers and practitioners to discuss the current state of Software Engineering research and Industrial Practice, and advance collaboration to reduce the gap between research and practice. Thanks to the strong contributions of the paper authors, we have been able to put together an exciting day with excellent prospects for achieving that goal.Our format for the workshop includes a mix of invited talks, regular and short paper presentations, talks from practitioners and round table discussions, in order to facilitate inclusion of presenters from both industry and academia. Keeping with the goal of a more interactive workshop, ample time has been included for questions and answers on the presentations, as well as …","Scholar articles SER&IP 2016R Shukla, S Sen, L Laird, J Bishop, W Moazzam…All 4 versions ","We cheerfully welcome you to the 3rd International Workshop on Software Engineering Research and Industrial Practice, held this year in Austin, Texas. The aim of our workshop is to bring together researchers and practitioners to discuss the current state of Software Engineering research and Industrial Practice, and advance collaboration to reduce the gap between research and practice. Thanks to the strong contributions of the paper authors, we have been able to put together an exciting day with excellent prospects for achieving that goal.",
"Guest Editorial to the Special Issue on Automation of Software Testing Hong Zhu, SC Cheung, Joseph R. Horgan and","J Jenny Li, Leonard Gallagher, Jeff Offutt, Meng-Luo Ji, Ji Wang, Shuhao Li, Zhi-Chang Qi, Mingsong Chen, Xiaokang Qiu, Wei Xu, Linzhang Wang, Jianhua Zhao, Xuandong Li, Aynur Abdurazik, Lijun Shan, Hong Zhu",Computer journal,Volume 52,,
Agile Software Development,Jeff Offutt,• XP Planning–Begins with the creation of “user stories”–Agile team assesses each story and assigns a cost–Stories are grouped into deliverable increments–A commitment is made on delivery date–After the first increment “project velocity” is used to help define subsequent delivery dates for other increments,Scholar articles Agile Software DevelopmentJ Offutt,• XP Planning–Begins with the creation of “user stories”–Agile team assesses each story and assigns a cost–Stories are grouped into deliverable increments–A commitment is made on delivery date–After the first increment “project velocity” is used to help define subsequent delivery dates for other increments,
"Introduction to Software Testing Chapter 2.1, 2.2 Overview Graph Coverage Criteria","Paul Ammann, Jeff Offutt","• Satisfaction: Given a set TR of test requirements for a criterion C, a set of tests T satisfies C on a graph if and only if for every test requirement in TR, there is a test path in path (T) that meets the test requirement tr","Scholar articles Introduction to Software Testing Chapter 2.1, 2.2 Overview Graph Coverage CriteriaP Ammann, J OffuttAll 3 versions ","• Satisfaction: Given a set TR of test requirements for a criterion C, a set of tests T satisfies C on a graph if and only if for every test requirement in TR, there is a test path in path (T) that meets the test requirement tr",
XML Advanced Topics,Jeff Offutt,M biihh XML dli–Must begin with the XML declaration–Must have one unique root element–All start tags must match end-tags–XML tags are case sensitive–All elements must be closed–All elements must be properly nested–All attribute values must be quoted–XML entities must be used for special characters,Scholar articles XML Advanced TopicsJ OffuttAll 2 versions ,M biihh XML dli–Must begin with the XML declaration–Must have one unique root element–All start tags must match end-tags–XML tags are case sensitive–All elements must be closed–All elements must be properly nested–All attribute values must be quoted–XML entities must be used for special characters,
Handling State in Web Applications,Jeff Offutt,"Handling State in Web Applications Tracking State Tracking State Information Information Page 
1 1 Handling State in Web Applications Jeff Offutt http://www.cs.gmu.edu/~offutt/ SWE 642 
Software Engineering for the World Wide Web sources: Professional Java Server Programming, 
Patzer, Wrox Web Technologies: A Computer Science Perspective, Jackson, Prentice-Hall 
Tracking State Tracking State Information Information • The initial versions of the web suffered 
from a lack of state: HTML Form Server HTML Page Data Info • If you wanted multiple screens, 
there was no way for data to be accumulated or stored 26-Sep-13 © Offutt 2 D1 D1+D2+D3 
Form1 Form2 Form3 Server Form4 Server D1+D2 D1+D2+D3+D4 D1 Server Server D1+D2 
D1+D2+D3 Page 2 2 Session Tracking • Web applications must maintain user states • This 
is called session tracking 26-Sep-13 © Offutt 3 Session Tracking (2) • Session tracking …",Scholar articles Handling State in Web ApplicationsJ OffuttAll 2 versions ,,
Deriving Tests from Software Architectures,Jeff Offutt,"Deriving Tests from Software Architectures Overview – Software Architecture Page 1 1 Deriving 
Tests from Software Architectures Jeff Offutt Information & Software Engineering George Mason 
University Fairfax, VA USA www.ise.gmu.edu/faculty/ofut/ ofut@ise.gmu.edu Zhenyi Jin, ITT 
Industries (PhD Dissertation) Supported by NSF and NIST. Joint research with: (C) Copyright 
2001, Offutt & Jin. All Rights Reserved. 2 Overview – Software Architecture • High level of 
abstraction • Components, connections, and configuration • Focus on interactions • Architecture 
Description Languages (ADLs) C5 C1 C4 C2 C3 C6 C1-C2 C4-C6 C5-C6 C2-C3-1 C2-C3-2 
Components Connectors Page 2 2 (C) Copyright 2001, Offutt & Jin. All Rights Reserved. 3 
Motivation • Software Architecture Research – System complexity increases – Better 
understanding and handling of larger systems – Reuse potential • Lack of Testing Techniques …",Scholar articles Deriving Tests from Software ArchitecturesJ OffuttAll 2 versions ,,
Generating Test Data From State-based Speci cations1,"A Jefferson Offutt, Shaoying Liu, Aynur Abdurazik","Although the majority of software testing in industry is conducted at the system level, most formal research has focused on the unit level. As a result, most system level testing techniques are only described informally. This paper presents formal testing criteria for system level testing that are based on formal specifications of the software. Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Formal specifications represent a significant opportunity for testing because they precisely describe what functions the software is supposed to provide in a form that can be easily manipulated. This paper presents general criteria for generating test inputs from state-based specifications. The criteria include techniques for generating tests at several levels of abstraction for specifications. These techniques provide coverage criteria that are based on the specifications, and are made up of several parts, including test prefixes that contain inputs necessary to put the software into the appropriate state for the test values. The test generation process includes several steps for transforming specifications to tests. Empirical results from a comparative case study application of these criteria are presented.","Scholar articles Generating Test Data From State-based Speci cations1AJ Offutt, S Liu, A AbdurazikRelated articles All 3 versions ","Although the majority of software testing in industry is conducted at the system level, most formal research has focused on the unit level. As a result, most system level testing techniques are only described informally. This paper presents formal testing criteria for system level testing that are based on formal specifications of the software. Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Formal specifications represent a significant opportunity for testing because they precisely describe what functions the software is supposed to provide in a form that can be easily manipulated. This paper presents general criteria for generating test inputs from state-based specifications. The criteria include techniques for generating tests at several levels of abstraction for specifications. These techniques provide coverage criteria that are based on the specifications, and are made up of several parts, including test prefixes that contain inputs necessary to put the software into the appropriate state for the test values. The test generation process includes several steps for transforming specifications to tests. Empirical results from a comparative case study application of these criteria are presented.",
Mutation 2007 Organisation,"Mark Harman, John Clark, Jeff Offutt, Phil McMinn, Shuang Wang","Organization Toggle navigation IEEE Computer Society Digital Library Jobs Tech News 
Resource Center Press Room Advertising About Us IEEE IEEE Computer Society IEEE 
Computer Society Digital Library My Subscriptions Magazines Journals Conference Proceedings 
Institutional Subscriptions IEEE IEEE Computer Society More Jobs Tech News Resource Center 
Press Room Advertising About Us Cart All Advanced Search Conference Cover Image Download 
1.Home 2.Proceedings 3.taicpart-mutation 2007 Organization 2007, pp. xx, DOI Bookmark: 
10.1109/TAIC.PART.2007.45 Keywords Authors xxMutation 2007 Organisation 
◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘◘ General 
Chair: Mark Harman (King’s College London) Programme Co-Chairs: John Clark (University of 
York) & Jeff Offutt (George Mason University) Publicity Chair: Phil McMinn (University of Sheffield) …","Scholar articles Mutation 2007 OrganisationM Harman, J Clark, J Offutt, P McMinn, S WangAll 2 versions ",,
TDD: 1st International Workshop on Test-Driven Development,"Laurie Williams, Jeff Offutt, Michael Feathers, David Janzen, Philip Johnson, Catherine Louis, Grigori Melnik, Gerard Meszaros","TDD: 1st International Workshop on Test-Driven Development Committee | IEEE Conference 
Publication | IEEE Xplore Skip to Main Content TDD: 1st International Workshop on Test-Driven 
Development Committee Abstract: Provides a listing of current committee members. Published in: 
2010 Third International Conference on Software Testing, Verification, and Validation Workshops 
Article #: Date of Conference: 06-10 April 2010 Date Added to IEEE Xplore: 13 May 2010 ISBN 
Information: Electronic ISBN: 978-1-4244-6774-7 Print ISBN: 978-1-4244-6773-0 CD: 
978-0-7695-4050-4 INSPEC Accession Number: Persistent Link: 
https://xplorestaging.ieee.org/servlet/opac?punumber=5463512 More » Publisher: IEEE IEEE 
Account Change Username/Password Update Address Purchase Details Payment Options Order 
History View Purchased Documents Profile Information Communications Preferences Profession and …","Scholar articles TDD: 1st International Workshop on Test-Driven DevelopmentL Williams, J Offutt, M Feathers, D Janzen, P Johnson…",,
Mutation: 5th International Workshop on Mutation Analysis,"Lydie du Bousquet, Jeremy Bradbury, Gordon Fraser, Roger Alexander, Paul Ammann, Leonardo Bottaci, Byoungiu Choi, John A Clark, James Cordy, Rich DeMillo, Mark Hampton, Mark Harman, Rob Hierons, Bill Howden, Gregory M Kapfhammer, Jose Carlos Maldonado, Mercedes Merayo, Phil McMinn, Akbar Siami Namin, Jeff Offutt, Macario Polo, David Schuler, Yves Le Traon, Laurie Williams, Eric Wong, Lu Zhang","Mutation: 5th International Workshop on Mutation Analysis Committee Toggle navigation IEEE 
Computer Society Digital Library Jobs Tech News Resource Center Press Room Browse By 
Date Advertising About Us IEEE IEEE Computer Society IEEE Computer Society Digital Library 
My Subscriptions Magazines Journals Conference Proceedings Institutional Subscriptions 
IEEE IEEE Computer Society More Jobs Tech News Resource Center Press Room Browse 
By Date Advertising About Us Cart All Advanced Search Conference Cover Image Download 
1.Home 2.Proceedings 3.icstw 2010 Mutation: 5th International Workshop on Mutation 
Analysis Committee 2010, pp. xiii, DOI Bookmark: 10.1109/ICSTW.2010.69 Keywords Authors 
, , ,Mutation: 5th International Workshop ,on Mutation Analysis , , ,Workshop Chairs ,Lydie 
du Bousquet, ,Laboratoire d’Informatique de Grenoble (LIG), France ,Jeremy Bradbury, ,…","Scholar articles Mutation: 5th International Workshop on Mutation AnalysisL du Bousquet, J Bradbury, G Fraser, R Alexander…All 2 versions ",,
A Message from the Mutation 2007 Programme Co-Chairs,"John Clark, Jeff Offutt","We are very pleased with the outstanding submissions reflecting a vibrant research community. The programme committee was extremely diligent and provided the submitters with very helpful suggestions. Reviewing is hard work for low pay, and we hope we can speak for the authors in thanking the programme committee for their efforts.We are also honoured to have one of the founders of mutation as our keynote speaker. Richard A. DeMillo, along with Richard J. Lipton and Fred G. Sayward, started this field over 30 years ago. DeMillo led some of the most successful research projects in software testing, including the Mothra mutation testing project. We thank Rich for attending and presenting at the workshop.","Scholar articles A Message from the Mutation 2007 Programme Co-ChairsJ Clark, J Offutt","We are very pleased with the outstanding submissions reflecting a vibrant research community. The programme committee was extremely diligent and provided the submitters with very helpful suggestions. Reviewing is hard work for low pay, and we hope we can speak for the authors in thanking the programme committee for their efforts.",
Quality Assurance and Testing of Web-Based Applications,"Hong Zhu, David Kung, Shing-Chi Cheung, Jose Maldonado, Jeff Offutt, Amie Souter, Wei-tek Tsai, TY Chen","Conference proceedings front matter may contain various advertisements, welcome messages, committee or program information, and other miscellaneous conference information. This may in some cases also include the cover art, table of contents, copyright statements, title-page or half title-pages, blank pages, venue maps or other general information relating to the conference that was part of the original conference proceedings.","Scholar articles Quality Assurance and Testing of Web-Based ApplicationsH Zhu, D Kung, SC Cheung, J Maldonado, J Offutt…All 2 versions ","Conference proceedings front matter may contain various advertisements, welcome messages, committee or program information, and other miscellaneous conference information. This may in some cases also include the cover art, table of contents, copyright statements, title-page or half title-pages, blank pages, venue maps or other general information relating to the conference that was part of the original conference proceedings.",
